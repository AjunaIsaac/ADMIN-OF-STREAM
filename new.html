<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Zone Movies Admin Panel</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --primary-bg: #0b0f30;
            --secondary-bg: #121740;
            --accent-color: #d1e231;
            --text-color: #ffffff;
            --gradient-start: #ff006b;
            --gradient-mid: #FF9800;
            --gradient-end: #FFEB3B;
            --danger-color: #f44336;
            --success-color: #4CAF50;
            --info-color: #2196F3;
            --warn-color: #f39c12;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background-color: var(--primary-bg); color: var(--text-color); display: flex; min-height: 100vh; overflow-x: hidden; flex-direction: column; } /* Adjusted to min-height and overflow-x hidden */

        /* Main Menu / Sidebar */
        #mainMenu {
            position: fixed; /* Keep fixed */
            top: 0;
            left: -260px; /* Default closed state */
            width: 250px;
            height: 100%;
            background-color: var(--secondary-bg);
            padding-top: 60px;
            transition: left 0.3s ease-in-out;
            z-index: 1100;
            border-right: 2px solid var(--accent-color);
            box-shadow: 5px 0 15px rgba(0,0,0,0.2);
        }
        #mainMenu.open { left: 0; } /* Open state */
        #mainMenu .menu-header { color: var(--accent-color); padding: 10px 20px; font-size: 1.5em; text-align: center; border-bottom: 1px solid #333; margin-bottom: 20px; }
        #mainMenu a { padding: 15px 20px; text-decoration: none; font-size: 18px; color: var(--text-color); display: flex; align-items: center; gap: 15px; transition: background-color 0.2s, color 0.2s; cursor: pointer; }
        #mainMenu a:hover { background-color: var(--primary-bg); }
        #mainMenu a.active { background-color: var(--accent-color); color: var(--primary-bg); font-weight: bold; }

        /* Menu Toggle Button */
        #menuToggleBtn {
            position: fixed;
            top: 15px; /* Adjusted for better visibility */
            left: 15px; /* Adjusted for better visibility */
            background: var(--secondary-bg);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 1200;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #menuToggleBtn:hover { background-color: var(--primary-bg); }

        /* Main Content Area */
        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            min-height: 100vh; /* Ensure it takes full height */
            transition: margin-left 0.3s ease-in-out;
            width: 100%;
            margin-left: 0; /* Default for closed menu/mobile */
        }

        /* Login Container */
        .login-container {
            background-color: var(--secondary-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            margin: 50px auto;
            text-align: center;
        }

        /* Page Containers */
        .page-container {
            display: none;
            background-color: var(--secondary-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 1200px; /* Wider for new notification layout */
            margin: 20px auto;
        }
        .page-container.active { display: block; }

        h1, h2 { text-align: center; color: var(--accent-color); margin-bottom: 20px; }

        /* Admin Header (Top bar) */
        .admin-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 0;
            gap: 10px;
        }

        /* Logged in user email display */
        #adminEmailDisplay {
            font-size: 0.9em;
            color: #aaa;
            font-weight: normal;
            text-align: center;
            width: 100%;
            order: 3;
        }

        /* Logout Button */
        .logout-btn {
            background: var(--danger-color);
            width: auto;
            padding: 10px 15px;
            font-size: 14px;
            order: 2;
        }

        /* Form elements */
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: bold; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid #333; border-radius: 5px; background-color: var(--primary-bg); color: var(--text-color); font-size: 16px; }
        .form-group input[readonly] { background-color: #2a2f50; cursor: not-allowed; opacity: 0.7; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--accent-color); }
        button { display: inline-block; width: 100%; padding: 15px; background: linear-gradient(45deg, var(--gradient-start), var(--gradient-mid), var(--gradient-end)); color: var(--text-color); border: none; border-radius: 5px; font-size: 18px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s; margin-top: 10px; position: relative; text-align: center; }
        button:hover { transform: translateY(-2px); opacity: 0.9; }
        button.loading { color: transparent !important; pointer-events: none; }
        button .spinner { display: none; border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid white; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        button.loading .spinner { display: block; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        .checkbox-group { display: flex; flex-wrap: wrap; gap: 10px 20px; background-color: var(--primary-bg); padding: 15px; border-radius: 5px; border: 1px solid #333; }
        .checkbox-group label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: normal; }
        .checkbox-group input[type="checkbox"] { height: 18px; width: 18px; cursor: pointer; }
        .message { margin-top: 20px; padding: 12px; border-radius: 5px; text-align: center; display: none; }
        .message.success { background-color: var(--success-color); }
        .message.error { background-color: var(--danger-color); }
        .message.info { background-color: var(--info-color); }
        .message.warn { background-color: var(--warn-color); } /* Added for warnings */
        .result-item { background-color: var(--primary-bg); padding: 10px; margin-bottom: 5px; border-radius: 5px; display: flex; flex-direction: column; align-items: flex-start; justify-content: space-between; gap: 10px; }
        .result-item span { text-align: left; width: 100%; }
        .result-item-actions { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; justify-content: flex-start; }
        .action-btn { background-color: var(--accent-color) !important; color: var(--primary-bg) !important; padding: 8px 12px !important; border-radius: 5px !important; width: auto !important; font-size: 14px !important; margin-top: 0 !important; flex-grow: 1; min-width: 80px; }
        .action-btn.edit { background-color: var(--warn-color) !important; color: white !important; }
        .action-btn.delete { background-color: var(--danger-color) !important; color: white !important; }
        .action-btn.select-delete.selected { background-color: var(--success-color) !important; color: white !important; }
        .banner-nav-tabs { display: flex; flex-wrap: wrap; border-bottom: 1px solid var(--accent-color); margin-bottom: 20px; }
        .banner-tab-link { padding: 10px 15px; cursor: pointer; color: #aaa; border: none; background: none; font-size: 15px; flex-grow: 1; text-align: center; }
        .banner-tab-link.active { color: var(--accent-color); border-bottom: 2px solid var(--accent-color); font-weight: bold; }
        .banner-tab-content { display: none; }
        .banner-tab-content.active { display: block; }
        #allBannersContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 20px; }
        .banner-card { background-color: var(--primary-bg); border-radius: 8px; overflow: hidden; box-shadow: 0 4px 8px rgba(0,0,0,0.3); display: flex; flex-direction: column; }
        .banner-card img { width: 100%; height: 120px; object-fit: cover; background-color: #000; }
        .banner-card-content { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; }
        .banner-card h3 { font-size: 1em; color: var(--accent-color); margin-bottom: 5px; text-align: left; }
        .banner-card p { font-size: 0.8em; color: #ccc; margin-bottom: 10px; flex-grow: 1; line-height: 1.4; }
        .banner-card-actions { display: flex; gap: 8px; margin-top: auto; border-top: 1px solid #333; padding-top: 8px; }
        .banner-card-actions .action-btn { width: 100% !important; flex: 1; }
        .banner-card-actions .action-btn.delete { background-color: var(--danger-color) !important; color: white !important; }

        /* Styles for User Management Section */
        #userManagementPage .input-group { margin-bottom: 15px; }
        #userManagementPage .input-group label { display: block; margin-bottom: 8px; color: #ccc; font-size: 14px; }
        #userManagementPage .input-group input, #userManagementPage .input-group select { width: 100%; padding: 10px; background: #222; border: 1px solid #444; border-radius: 8px; color: white; font-size: 15px; }
        #userManagementPage .btn-secondary { background: #555; }
        #userManagementPage hr { border-color: #444; margin: 20px 0; }

        /* NEW: Styles for Notification Page */
        .notification-layout { display: flex; flex-wrap: wrap; gap: 30px; }
        .notification-form-col, .notification-preview-col { flex: 1; min-width: 300px; }
        .notification-preview-wrapper {
            background: rgba(0,0,0,0.2);
            border: 1px solid #444;
            padding: 20px;
            border-radius: 12px;
            height: 100%;
        }
        #previewImage {
            display: none;
            width: 100%;
            height: auto;
            margin-top: 12px;
            border-radius: 8px;
            object-fit: cover;
            border: 1px solid #333;
        }

        /* NEW: Styles for All Content Page */
        .movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted for more columns */
            gap: 20px;
            margin-top: 20px;
        }

        .content-card {
            background-color: var(--primary-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            text-align: center;
            position: relative; /* For the checkbox */
        }

        .content-card img {
            width: 100%;
            height: 250px; /* Increased height for better visibility */
            object-fit: cover;
            background-color: #000;
            border-bottom: 1px solid #333;
        }

        .content-card-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Pushes buttons to bottom */
        }

        .content-card h3 {
            font-size: 1.1em;
            color: var(--accent-color);
            margin-bottom: 5px;
            white-space: nowrap; /* Prevent title from wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis for long titles */
            padding: 0 5px; /* Add some padding */
        }

        .content-card p.vj-name {
            font-size: 0.8em;
            color: #ccc;
            margin-bottom: 10px;
            padding: 0 5px;
        }
        .content-card p.content-id-display,
        .content-card p.content-project-display {
            font-size: 0.75em;
            color: #999;
            margin-bottom: 3px;
        }

        .content-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px; /* Space from description */
            border-top: 1px solid #333;
            padding-top: 8px;
            justify-content: center; /* Center the buttons */
        }

        .content-card-actions .action-btn {
            flex: 1; /* Make buttons take equal space */
            min-width: unset; /* Override previous min-width */
            font-size: 0.9em !important;
            padding: 6px 10px !important;
        }

        .content-card input[type="checkbox"].select-card-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
            width: 24px;
            height: 24px;
            cursor: pointer;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-color);
            border-radius: 4px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .content-card input[type="checkbox"].select-card-checkbox:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .content-card input[type="checkbox"].select-card-checkbox:checked::before {
            content: '\2713'; /* Checkmark character */
            display: block;
            color: var(--primary-bg);
            font-size: 18px;
            line-height: 20px;
            text-align: center;
        }

        /* Styles for the new "For Sort Page Only" sections */
        .sort-page-section {
            margin-top: 30px;
            border-top: 1px solid #555;
            padding-top: 20px;
        }
        .sort-page-section h3 {
            color: var(--accent-color);
            margin-bottom: 15px;
            text-align: left;
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #mainMenu {
                left: -260px; /* Keep it off-screen by default on small screens */
                width: 250px;
                padding-top: 80px; /* Make space for toggle button */
            }
            /* .open class will apply `left: 0` */

            #menuToggleBtn {
                position: fixed;
                top: 15px;
                left: 15px;
            }

            .main-content {
                margin-left: 0; /* No margin on small screens when menu is closed */
                padding: 15px;
                margin-top: 60px; /* Space for the fixed toggle button */
            }

            /* Adjust admin header for small screens */
            .admin-header {
                flex-direction: column;
                align-items: flex-start;
                margin-top: 0; /* Remove extra top margin as main-content now handles it */
            }
            #pageTitle {
                width: 100%;
                text-align: left;
                font-size: 1.8em;
                margin-bottom: 10px;
                order: 1;
            }
            #adminEmailDisplay {
                width: 100%;
                text-align: left;
                font-size: 0.8em;
                margin-bottom: 10px;
                order: 3;
            }
            .logout-btn {
                width: auto;
                order: 2;
                margin-left: auto;
                margin-top: -40px; /* Pull it up to sit next to the title if space allows */
            }

            .page-container {
                padding: 15px;
                margin: 15px auto;
            }

            .result-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            .result-item-actions {
                flex-direction: column;
                width: 100%;
            }
            .action-btn {
                width: 100% !important;
            }

            #allBannersContainer {
                grid-template-columns: 1fr;
            }
            .banner-card img {
                height: 100px;
            }
            .banner-card-content {
                padding: 8px;
            }
            .banner-card h3 {
                font-size: 0.9em;
            }
            .banner-card p {
                font-size: 0.75em;
            }
            .banner-tab-link {
                font-size: 14px;
                padding: 8px 10px;
            }

            /* NEW: All Content Page mobile adjustments */
            .movie-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 15px;
            }
            .content-card img {
                height: 200px;
            }
            .content-card h3 {
                font-size: 1em;
            }
            .content-card p.vj-name {
                font-size: 0.7em;
            }
            .content-card-actions .action-btn {
                font-size: 0.8em !important;
                padding: 5px 8px !important;
            }
        }

        /* Desktop adjustments (min-width: 769px) */
        @media (min-width: 769px) {
            body {
                flex-direction: row; /* Main content and menu side-by-side */
            }

            #mainMenu {
                left: 0; /* Default open state on desktop */
                box-shadow: 5px 0 15px rgba(0,0,0,0.2); /* Re-add shadow for fixed menu */
            }

            #menuToggleBtn {
                top: 15px; /* Stay at top */
                left: calc(250px + 15px); /* Positioned relative to the open menu, +15px for spacing */
                transition: left 0.3s ease-in-out; /* Add transition for button too */
            }
            #mainMenu.open + #menuToggleBtn { /* When menu is open, move toggle button */
                left: calc(250px + 15px);
            }
            #mainMenu:not(.open) + #menuToggleBtn { /* When menu is NOT open, move toggle button back */
                left: 15px;
            }


            .main-content {
                margin-left: 250px; /* Space for the open sidebar */
                padding-top: 20px; /* Reset top padding from mobile */
            }

            /* Admin header for desktop */
            .admin-header {
                flex-direction: row;
                align-items: center;
                margin-top: 0;
            }
            #pageTitle {
                text-align: center;
                flex-grow: 1;
                order: initial;
            }
            #adminEmailDisplay {
                font-size: 14px;
                text-align: right;
                width: auto;
                margin-left: 20px;
                order: initial;
            }
            .logout-btn {
                width: auto;
                order: initial;
                margin-left: 15px;
                margin-top: 0;
            }
            
            .result-item {
                flex-direction: row;
                align-items: center;
            }
            .result-item-actions {
                flex-direction: row;
                width: auto;
            }
            .action-btn {
                width: auto !important;
            }
        }
    </style>
</head>
<body>

    <div id="loginScreen" class="main-content">
        <div class="login-container">
            <h1>Admin Login</h1>
            <form id="loginForm">
                <div class="form-group"><label for="loginEmail">Email</label><input type="email" id="loginEmail" required></div>
                <div class="form-group"><label for="loginPassword">Password</label><input type="password" id="loginPassword" required></div>
                <button type="submit">Login<span class="spinner"></span></button>
            </form>
            <div id="loginMessage" class="message"></div>
        </div>
    </div>

    <div id="adminPanel" style="display: none; width: 100%;">
        <button id="menuToggleBtn"><i class="fas fa-bars"></i></button>
        <nav id="mainMenu">
            <div class="menu-header">Admin Menu</div>
            <a class="menu-link" data-page="addContentPage"><i class="fas fa-magic"></i> Add from TMDB</a>
            <a class="menu-link" data-page="manualAddPage"><i class="fas fa-edit"></i> Manual Add</a>
            <a class="menu-link" data-page="manageContentPage"><i class="fas fa-search"></i> Search & Edit/Delete</a>
            <a class="menu-link" data-page="allContentPage"><i class="fas fa-film"></i> All Content</a>
            <a class="menu-link" data-page="bannerPage"><i class="fas fa-images"></i> Manage Banners</a>
            <a class="menu-link" data-page="notificationPage"><i class="fas fa-paper-plane"></i> Send Notifications</a>
            <a class="menu-link" data-page="userManagementPage"><i class="fas fa-users-cog"></i> User Management</a>
            <a href="https://storage1.streamzonemovies.online" target="_blank"><i class="fas fa-server"></i> My Server</a>
        </nav>


        <div class="main-content" id="mainContentArea">
            <div class="admin-header">
                <h1 id="pageTitle"></h1>
                <span id="adminEmailDisplay" style="font-weight: normal;"></span>
                <button class="logout-btn" id="logoutBtn">Logout <i class="fas fa-sign-out-alt"></i></button>
            </div>

            <div id="addContentPage" class="page-container">
                <h2>Add Content from TMDB</h2>
                <form id="addMovieForm">
                    <div class="form-group"><label for="tmdbApiKey">TMDB API Key</label><input type="text" id="tmdbApiKey" value="f7a3b097ba7a990fd0c8ef3147646fb5" readonly></div>
                    <div class="form-group"><label for="primaryContentType">Primary Content Type</label><select id="primaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories (Select all that apply)</label>
                        <div class="checkbox-group" id="contentTypeCheckboxes">
                            <label><input type="checkbox" name="contentType" value="latest_uploads"> Latest Uploads</label>
                            <label class="movie-only-category"><input type="checkbox" name="contentType" value="Latest-Movies">Latest Movies</label>
                            <label><input type="checkbox" name="contentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="contentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="contentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="contentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="contentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="contentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="contentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="contentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="contentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="contentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="contentType" value="nigerian"> Nigerian Movies</label>
                            <label class="tv-only-category"><input type="checkbox" name="contentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label class="tv-only-category"><input type="checkbox" name="contentType" value="western_series"> Western Series</label>
                            <label class="tv-only-category"><input type="checkbox" name="contentType" value="Latest-TV-Series"> Latest Tv Shows</label>
                            <label class="tv-only-category"><input type="checkbox" name="contentType" value="k_dramas"> K Dramas</label>
                             <label><input type="checkbox" name="contentType" value="send_notification"> Send Notification</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="contentIdentifier">Content Name or TMDB ID</label><input type="text" id="contentIdentifier" placeholder="e.g., The Matrix or TMDB ID 603" required></div>
                    <div class="form-group"><label for="vjName">VJ Name</label><input type="text" id="vjName" required></div>
                    <div class="form-group video-url-group"><label for="videoSourceUrl">Video Source URL</label><input type="url" id="videoSourceUrl" placeholder="e.g., https://example.com/video.mp4"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="seriesData">Series Data (JSON)</label><textarea id="seriesData" rows="8"></textarea></div>
                    
                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesTMDB">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesTMDB">
                            </div>
                        </div>
                    </div>
                    <button type="submit" id="addContentBtn">Add Content<span class="spinner"></span></button>
                </form>
                <div id="addMessage" class="message"></div>
            </div>

            <div id="manualAddPage" class="page-container">
                <h2>Manually Add Content</h2>
                <form id="manualAddForm">
                    <div class="form-group"><label for="manualTitle">Title</label><input type="text" id="manualTitle" required></div>
                    <div class="form-group"><label for="manualOverview">Overview</label><textarea id="manualOverview" rows="4" required></textarea></div>
                    <div class="form-group"><label for="manualPosterUrl">Poster Image URL</label><input type="url" id="manualPosterUrl" required></div>
                    <div class="form-group"><label for="manualBackdropUrl">Backdrop Image URL</label><input type="url" id="manualBackdropUrl"></div>
                    <div class="form-group"><label for="manualVjName">VJ Name</label><input type="text" id="manualVjName" required></div>
                    <div class="form-group"><label for="manualPrimaryContentType">Primary Content Type</label><select id="manualPrimaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories</label>
                        <div class="checkbox-group" id="manualContentTypeCheckboxes">
                            <label><input type="checkbox" name="manualContentType" value="latest_uploads"> Latest Uploads</label>
                            <label class="movie-only-category"><input type="checkbox" name="manualContentType" value="Latest-Movies">Latest Movies</label>
                            <label><input type="checkbox" name="manualContentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="manualContentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="manualContentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="manualContentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="manualContentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="manualContentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="manualContentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="manualContentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="manualContentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="manualContentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="manualContentType" value="nigerian"> Nigerian Movies</label>
                            <label class="tv-only-category"><input type="checkbox" name="manualContentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label class="tv-only-category"><input type="checkbox" name="manualContentType" value="western_series"> Western Series</label>
                            <label class="tv-only-category"><input type="checkbox" name="manualContentType" value="Latest-TV-Series">Latest Tv shows</label>
                            <label class="tv-only-category"><input type="checkbox" name="manualContentType" value="k_dramas"> K Dramas</label>
                             <label><input type="checkbox" name="manualContentType" value="send_notification"> Send Notification</label>
                        </div>
                    </div>

                    <div class="form-group genre-selection-group">
                        <label>Genres (Select all that apply)</label>
                        <div class="checkbox-group" id="manualGenreCheckboxes">
                            <label><input type="checkbox" name="manualGenre" value="action"> Action</label>
                            <label><input type="checkbox" name="manualGenre" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="manualGenre" value="animation"> Animation</label>
                            <label><input type="checkbox" name="manualGenre" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="manualGenre" value="crime"> Crime</label>
                            <label><input type="checkbox" name="manualGenre" value="documentary"> Documentary</label>
                            <label><input type="checkbox" name="manualGenre" value="drama"> Drama</label>
                            <label><input type="checkbox" name="manualGenre" value="family"> Family</label>
                            <label><input type="checkbox" name="manualGenre" value="fantasy"> Fantasy</label>
                            <label><input type="checkbox" name="manualGenre" value="history"> History</label>
                            <label><input type="checkbox" name="manualGenre" value="horror"> Horror</label>
                            <label><input type="checkbox" name="manualGenre" value="music"> Music</label>
                            <label><input type="checkbox" name="manualGenre" value="mystery"> Mystery</label>
                            <label><input type="checkbox" name="manualGenre" value="romance"> Romance</label>
                            <label><input type="checkbox" name="manualGenre" value="science-fiction"> Science Fiction</label>
                            <label><input type="checkbox" name="manualGenre" value="tv-movie"> TV Movie</label>
                            <label><input type="checkbox" name="manualGenre" value="thriller"> Thriller</label>
                            <label><input type="checkbox" name="manualGenre" value="war"> War</label>
                            <label><input type="checkbox" name="manualGenre" value="western"> Western</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="manualReferenceId">Unique Text ID (e.g., mercy-for-none)</label><input type="text" id="manualReferenceId" placeholder="Enter a unique text identifier" required></div>

                    <div class="form-group video-url-group"><label for="manualVideoSourceUrl">Video Source URL</label><input type="url" id="manualVideoSourceUrl"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="manualSeriesData">Series Data (JSON)</label><textarea id="manualSeriesData" rows="8"></textarea></div>

                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesManual">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesManual">
                            </div>
                        </div>
                    </div>
                    <button type="submit" id="manualAddContentBtn">Add Manually<span class="spinner"></span></button>
                </form>
                <div id="manualAddMessage" class="message"></div>
            </div>

            <div id="manageContentPage" class="page-container">
                <h2>Search & Manage Content</h2>
                <form id="manageContentForm">
                    <div class="form-group">
                        <label for="manageContentIdentifier">Search by Content Name, TMDB ID or Unique Text ID</label>
                        <input type="text" id="manageContentIdentifier" required>
                    </div>
                    <button type="button" id="searchManageBtn">Search Content<span class="spinner"></span></button>
                </form>
                <div id="manageSearchResults" style="margin-top: 20px;"></div>
                <button type="button" id="confirmDeleteBtn" style="display: none; background-color: var(--danger-color);">Delete Selected Content<span class="spinner"></span></button>
                <div id="manageMessage" class="message"></div>
            </div>

            <div id="allContentPage" class="page-container">
                <h2>All Available Content</h2>
                <div class="form-group">
                    <label for="allContentFilter">Filter by Category:</label>
                    <select id="allContentFilter">
                        <option value="all">All</option>
                        <option value="latest_uploads">Latest Uploads</option>
                        <option value="Latest-Movies">Latest Movies</option>
                        <option value="most_liked">Most Liked</option>
                        <option value="animation">Animation</option>
                        <option value="indian">Indian</option>
                        <option value="horror">Horror</option>
                        <option value="comedy">Comedy</option>
                        <option value="romance">Romance</option>
                        <option value="adventure">Adventure</option>
                        <option value="scifi-fantasy">Sci-fi & Fantasy</option>
                        <option value="action-thriller">Action & Thriller</option>
                        <option value="high-school">High School</option>
                        <option value="nigerian">Nigerian Movies</option>
                        <option value="upcoming_shows">Upcoming Shows</option>
                        <option value="western_series">Western Series</option>
                        <option value="Latest-TV-Series">Latest Tv Shows</option>
                        <option value="k_dramas">K Dramas</option>
                        <option value="send_notification">Send Notification</option>
                    </select>
                </div>
                <div id="allContentContainer" class="movie-grid"></div>
                <button type="button" id="deleteSelectedAllContentBtn" style="display: none; background-color: var(--danger-color); margin-top: 20px;">Delete Selected Content (<span id="selectedAllContentCount">0</span>)<span class="spinner"></span></button>
                <div id="allContentMessage" class="message"></div>
            </div>

            <div id="editContentPage" class="page-container">
                <h2>Edit Content</h2>
                <form id="editContentForm">
                    <input type="hidden" id="editDocId">
                    <div class="form-group"><label for="editTitle">Title</label><input type="text" id="editTitle" required></div>
                    <div class="form-group"><label for="editOverview">Overview</label><textarea id="editOverview" rows="4" required></textarea></div>
                    <div class="form-group"><label for="editPosterUrl">Poster Image URL</label><input type="url" id="editPosterUrl" required></div>
                    <div class="form-group"><label for="editBackdropUrl">Backdrop Image URL</label><input type="url" id="editBackdropUrl"></div>
                    <div class="form-group"><label for="editVjName">VJ Name</label><input type="text" id="editVjName" required></div>
                    <div class="form-group"><label for="editPrimaryContentType">Primary Content Type</label><select id="editPrimaryContentType" class="primary-content-type-selector" required><option value="movie">Movie</option><option value="tv">TV Series</option></select></div>
                    <div class="form-group media-categories-group">
                        <label>Categories</label>
                        <div class="checkbox-group" id="editContentTypeCheckboxes">
                            <label><input type="checkbox" name="editContentType" value="latest_uploads"> Latest Uploads</label>
                            <label class="movie-only-category"><input type="checkbox" name="editContentType" value="Latest-Movies">Latest Movies</label>
                            <label><input type="checkbox" name="editContentType" value="most_liked"> Most Liked</label>
                            <label><input type="checkbox" name="editContentType" value="animation"> Animation</label>
                            <label><input type="checkbox" name="editContentType" value="indian"> Indian</label>
                            <label><input type="checkbox" name="editContentType" value="horror"> Horror</label>
                            <label><input type="checkbox" name="editContentType" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="editContentType" value="romance"> Romance</label>
                            <label><input type="checkbox" name="editContentType" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="editContentType" value="scifi-fantasy"> Sci-fi & Fantasy</label>
                            <label><input type="checkbox" name="editContentType" value="action-thriller"> Action & Thriller</label>
                            <label><input type="checkbox" name="editContentType" value="high-school"> High School</label>
                            <label><input type="checkbox" name="editContentType" value="nigerian"> Nigerian Movies</label>
                            <label class="tv-only-category"><input type="checkbox" name="editContentType" value="upcoming_shows"> Upcoming Shows</label>
                            <label class="tv-only-category"><input type="checkbox" name="editContentType" value="western_series"> Western Series</label>
                            <label class="tv-only-category"><input type="checkbox" name="editContentType" value="Latest-TV-Series"> Latest Tv shows</label>
                            <label class="tv-only-category"><input type="checkbox" name="editContentType" value="k_dramas"> K Dramas</label>
                             <label><input type="checkbox" name="editContentType" value="send_notification"> Send Notification</label>
                        </div>
                    </div>

                    <div class="form-group genre-selection-group">
                        <label>Genres (Select all that apply)</label>
                        <div class="checkbox-group" id="editGenreCheckboxes">
                            <label><input type="checkbox" name="editGenre" value="action"> Action</label>
                            <label><input type="checkbox" name="editGenre" value="adventure"> Adventure</label>
                            <label><input type="checkbox" name="editGenre" value="animation"> Animation</label>
                            <label><input type="checkbox" name="editGenre" value="comedy"> Comedy</label>
                            <label><input type="checkbox" name="editGenre" value="crime"> Crime</label>
                            <label><input type="checkbox" name="editGenre" value="documentary"> Documentary</label>
                            <label><input type="checkbox" name="editGenre" value="drama"> Drama</label>
                            <label><input type="checkbox" name="genre" value="family"> Family</label>
                            <label><input type="checkbox" name="editGenre" value="fantasy"> Fantasy</label>
                            <label><input type="checkbox" name="editGenre" value="history"> History</label>
                            <label><input type="checkbox" name="editGenre" value="horror"> Horror</label>
                            <label><input type="checkbox" name="editGenre" value="music"> Music</label>
                            <label><input type="checkbox" name="editGenre" value="mystery"> Mystery</label>
                            <label><input type="checkbox" name="editGenre" value="romance"> Romance</label>
                            <label><input type="checkbox" name="editGenre" value="science-fiction"> Science Fiction</label>
                            <label><input type="checkbox" name="editGenre" value="tv-movie"> TV Movie</label>
                            <label><input type="checkbox" name="editGenre" value="thriller"> Thriller</label>
                            <label><input type="checkbox" name="editGenre" value="war"> War</label>
                            <label><input type="checkbox" name="editGenre" value="western"> Western</label>
                        </div>
                    </div>
                    <div class="form-group"><label for="editReferenceId">Reference ID (TMDB or Custom Text)</label><input type="text" id="editReferenceId" placeholder="TMDB ID or your unique text ID"></div>

                    <div class="form-group video-url-group"><label for="editVideoSourceUrl">Video Source URL</label><input type="url" id="editVideoSourceUrl"></div>
                    <div class="form-group series-data-group" style="display: none;"><label for="editSeriesData">Series Data (JSON)</label><textarea id="editSeriesData" rows="8"></textarea></div>

                    <hr class="sort-page-section" />
                    <div class="sort-page-section">
                        <h3>For Sort Page Only</h3>
                        <div class="form-group">
                            <label>VJs for Sort Page</label>
                            <div class="checkbox-group" id="sortVjsCheckboxesEdit">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Genres for Sort Page</label>
                            <div class="checkbox-group" id="sortGenresCheckboxesEdit">
                            </div>
                        </div>
                    </div>
                    <button type="submit" id="updateContentBtn">Update Content<span class="spinner"></span></button>
                    <button type="button" id="cancelEditBtn" style="background-color: gray; margin-top: 10px;">Cancel Edit</button>
                </form>
                <div id="editMessage" class="message"></div>
            </div>

            <div id="bannerPage" class="page-container">
                <div class="banner-nav-tabs">
                    <button class="banner-tab-link" data-tab="viewBannersTab">View All Banners</button>
                    <button class="banner-tab-link" data-tab="addBannerTab">Add/Edit Banner</button>
                </div>
                
                <div id="addBannerTab" class="banner-tab-content">
                    <h2 id="bannerFormTitle">Add New Banner</h2>
                    <form id="addEditBannerForm">
                        <input type="hidden" id="bannerDocId">
                        <div class="form-group"><label for="bannerTitle">Banner Title</label><input type="text" id="bannerTitle" required></div>
                        <div class="form-group"><label for="bannerImageUrl">Image URL</label><input type="text" id="bannerImageUrl" required></div>
                        <div class="form-group"><label for="bannerDescription">Description</label><textarea id="bannerDescription" rows="3"></textarea></div>
                        <div class="form-group"><label for="bannerLink">"Watch Now" Link</label><input type="text" id="bannerLink" required></div>
                        <button type="submit" id="saveBannerBtn">Save Banner<span class="spinner"></span></button>
                        <button type="button" id="cancelEditBannerBtn" style="display:none; background: gray;">Cancel Edit / New</button>
                    </form>
                    <div id="addBannerMessage" class="message"></div>
                </div>

                <div id="viewBannersTab" class="banner-tab-content">
                    <h2>All Available Banners</h2>
                    <div id="allBannersContainer"></div>
                    <div id="viewBannersMessage" class="message"></div>
                </div>
            </div>
            
            <div id="notificationPage" class="page-container">
                <h2>Notification Dashboard</h2>
                <p style="text-align:center; color: #ccc; margin-top: -15px; margin-bottom: 25px;">Send notifications to all your users instantly.</p>
                <div class="notification-layout">
                    <div class="notification-form-col">
                        <form id="notificationForm">
                            <div class="form-group"><label for="notifTitle">Title</label><input type="text" id="notifTitle" placeholder="New Movie Alert!" required></div>
                            <div class="form-group"><label for="notifBody">Body</label><textarea id="notifBody" rows="4" placeholder="Check out the latest blockbuster..." required></textarea></div>
                            <div class="form-group"><label for="notifImageUrl">Image URL <span style="color: #888; font-weight: normal;">(Optional)</span></label><input type="url" id="notifImageUrl" placeholder="https://example.com/image.jpg"></div>
                            <div class="form-group"><label for="notifUrl">Page to Open <span style="color: #888; font-weight: normal;">(Optional)</span></label><input type="url" id="notifUrl" placeholder="https://app.streamzonemovies.online/page.html"></div>
                            <button type="submit" id="sendNotificationBtn">Send Notification <i class="fas fa-paper-plane"></i><span class="spinner"></span></button>
                        </form>
                        <div id="notificationMessage" class="message"></div>
                    </div>
                    <div class="notification-preview-col">
                        <div class="notification-preview-wrapper">
                            <h3 style="text-align: center; color: var(--accent-color); margin-bottom: 15px;">Live Preview</h3>
                            <div style="display: flex; align-items: center; margin-bottom: 8px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;">
                                <img src="https://placehold.co/24x24/d1e231/0b0f30?text=S" alt="App Icon" style="width: 24px; height: 24px; border-radius: 50%; margin-right: 8px;">
                                <span style="font-size: 13px; font-weight: bold; color: var(--text-color);">Stream Zone Movies</span>
                                <span style="font-size: 13px; color: #aaa; margin-left: auto;">now</span>
                            </div>
                            <div style="padding-left: 32px; margin-top: 10px;">
                                <h4 id="previewTitle" style="font-weight: bold; color: var(--text-color); margin: 0 0 4px 0; font-size: 16px;">Notification Title</h4>
                                <p id="previewBody" style="font-size: 14px; color: #ccc; margin: 0;">Notification body will appear here...</p>
                            </div>
                            <img id="previewImage" alt="Notification Image">
                        </div>
                    </div>
                </div>
            </div>

            <div id="userManagementPage" class="page-container">
                <h2>User Management Panel</h2>
                
                <div class="input-group">
                    <label for="user-search-email">Search User by Email</label>
                    <input type="email" id="user-search-email" placeholder="user@example.com" />
                </div>
                <button class="btn" id="user-search-btn">Search User</button>

                <div id="user-message-area" class="message hidden"></div>
                <hr class="hidden" id="user-form-divider" />

                <div id="user-edit-form-section" class="hidden">
                    <h3 id="user-form-title">Edit User</h3>
                    <div class="input-group"><label for="user-doc-id">Document ID (User UID)</label><input type="text" id="user-doc-id" disabled /></div>
                    <div class="input-group"><label for="user-edit-name">Full Name</label><input type="text" id="user-edit-name" /></div>
                    <div class="input-group"><label for="user-edit-email">Email</label><input type="email" id="user-edit-email" /></div>
                    <div class="input-group"><label for="user-edit-activated">Account Activated</label><select id="user-edit-activated"><option value="true">True</option><option value="false">False</option></select></div>
                    <div class="input-group"><label for="user-edit-expiresAt">Subscription Expiration</label><input type="datetime-local" id="user-edit-expiresAt" /></div>
                    <button class="btn" id="user-update-btn">Update Document</button>
                    <button class="btn btn-secondary" id="user-create-btn">Create New Document</button>
                </div>
            </div>

        </div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    
<script>
    document.addEventListener('DOMContentLoaded', () => {
    // --- Firebase Configuration ---
    const firebaseConfig = {
    apiKey: "AIzaSyAn2vbkT9yjyWtJzNSHgRureco5gEjYd_Q",
    authDomain: "stream-zone-movies-a83c1.firebaseapp.com",
    projectId: "stream-zone-movies-a83c1",
    storageBucket: "stream-zone-movies-a83c1.appspot.com",
    messagingSenderId: "148342664213",
    appId: "1:148342664213:web:56df2549cc480df7cf721c"
};
    // --- Initialize Firebase App ---
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore(app);
    const auth = firebase.auth(app);
    
    // --- DOM Element References ---
    const loginScreen = document.getElementById('loginScreen');
    const adminPanel = document.getElementById('adminPanel');
    const mainMenu = document.getElementById('mainMenu');
    const menuToggleBtn = document.getElementById('menuToggleBtn');
    const pageTitle = document.getElementById('pageTitle');
    const adminEmailDisplay = document.getElementById('adminEmailDisplay'); 
    const logoutBtn = document.getElementById('logoutBtn');
    const loginMessage = document.getElementById('loginMessage');
    const mainContentArea = document.getElementById('mainContentArea'); 

    // Content Management Elements
    const addMovieForm = document.getElementById('addMovieForm');
    const addContentBtn = document.getElementById('addContentBtn');
    const addMessage = document.getElementById('addMessage');
    const manualAddForm = document.getElementById('manualAddForm');
    const manualAddBtn = document.getElementById('manualAddContentBtn');
    const manualAddMessage = document.getElementById('manualAddMessage');
    const searchManageBtn = document.getElementById('searchManageBtn');
    const manageSearchResults = document.getElementById('manageSearchResults');
    const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
    const manageMessage = document.getElementById('manageMessage');
    const editContentForm = document.getElementById('editContentForm');
    const updateContentBtn = document.getElementById('updateContentBtn');
    const editMessage = document.getElementById('editMessage');
    const cancelEditBtn = document.getElementById('cancelEditBtn');

    // Banner Management Elements
    const bannerNavTabs = document.querySelector('.banner-nav-tabs');
    const addEditBannerForm = document.getElementById('addEditBannerForm');
    const bannerFormTitle = document.getElementById('bannerFormTitle');
    const bannerDocId = document.getElementById('bannerDocId');
    const saveBannerBtn = document.getElementById('saveBannerBtn');
    const cancelEditBannerBtn = document.getElementById('cancelEditBannerBtn');
    const addBannerMessage = document.getElementById('addBannerMessage');
    const allBannersContainer = document.getElementById('allBannersContainer');
    const viewBannersMessage = document.getElementById('viewBannersMessage');
    let selectedMoviesForDeletion = new Set(); // For manageContentPage search results

    // User Management Elements
    const userSearchEmailInput = document.getElementById('user-search-email');
    const userSearchBtn = document.getElementById('user-search-btn');
    const userMessageArea = document.getElementById('user-message-area');
    const userEditFormSection = document.getElementById('user-edit-form-section');
    const userFormDivider = document.getElementById('user-form-divider');
    const userDocIdInput = document.getElementById('user-doc-id');
    const userEditNameInput = document.getElementById('user-edit-name');
    const userEditEmailInput = document.getElementById('user-edit-email');
    const userEditActivatedSelect = document.getElementById('user-edit-activated');
    const userEditExpiresAtInput = document.getElementById('user-edit-expiresAt');
    const userUpdateBtn = document.getElementById('user-update-btn');
    const userCreateBtn = document.getElementById('user-create-btn');
    const userFormTitle = document.getElementById('user-form-title'); 

    // All Content Page Elements
    const allContentContainer = document.getElementById('allContentContainer');
    const allContentMessage = document.getElementById('allContentMessage');
    const allContentFilter = document.getElementById('allContentFilter');
    const deleteSelectedAllContentBtn = document.getElementById('deleteSelectedAllContentBtn');
    const selectedAllContentCount = document.getElementById('selectedAllContentCount');
    let selectedAllContentForDeletion = new Set();
    
    // --- Notification Panel Elements ---
    // **CRITICAL:** Replace this with YOUR actual Firebase Function URL from deployment
    const firebaseFunctionUrl = 'https://sendnotification-i7fenevlta-uc.a.run.app';
    
    const notifForm = document.getElementById('notificationForm');
    const sendNotificationBtn = document.getElementById('sendNotificationBtn');
    const notificationMessage = document.getElementById('notificationMessage');
    const notifTitleInput = document.getElementById('notifTitle');
    const notifBodyInput = document.getElementById('notifBody');
    const notifImageUrlInput = document.getElementById('notifImageUrl');
    // NEW: Added this line for the URL input
    const notifUrlInput = document.getElementById('notifUrl'); 
    const previewTitle = document.getElementById('previewTitle');
    const previewBody = document.getElementById('previewBody');
    const previewImage = document.getElementById('previewImage');

    // NEW: VJ and Genre Lists for Sort Page
    const VJ_LIST = [
        "Vj Junior","Vj TONNY", "Vj Emmy", "VJ NEIL", "Vj Jovan", "Vj Tom", "Vj Shao Khan", "Vj Jingo", "Vj Ice P", "Vj Kevo",
        "Vj Kevin", "Vj Kriss Sweet", "Vj Hd", "Vj Dan De", "Vj Sammy", "Vj Ivo", "Vj Isma K", "Vj Little T", "Vj Mox",
        "Vj Muba", "Vj Eddy", "Vj Kam", "Vj Lance", "Vj KS", "Vj Ulio", "Vj Aaron", "Vj Cabs", "Vj Banks", "Vj Jimmy",
        "Vj Baros","Vj SOUL","Vj SON", "Vj Kimuli", "Vj Fredy", "Vj Jumpers", "Vj Ashim", "Vj Pauleta", "Vj Martin K", "Vj Henrico", "Vj Uncle T","Vj RONAGE"
    ];
    const GENRE_LIST = [
        "Action", "Horror", "Series", "Adventure", "Love Story", "Comedy", "Crime", "Family", "Sci FI", "Romance",
        "Kungu Fu", "Drama", "Sport", "Thriller", "Animation", "Documentary", "Fantasy", "History", "Music", "Mystery",
        "War", "Western"
    ];

    // Function to populate checkbox groups
    function populateCheckboxes(containerId, namePrefix, list, selectedValues = []) {
        const container = document.getElementById(containerId);
        if (!container) return; // Ensure container exists
        container.innerHTML = ''; // Clear existing checkboxes

        list.forEach(item => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = namePrefix;
            checkbox.value = item;
            // Ensure selectedValues is treated as an array even if it's null/undefined
            checkbox.checked = Array.isArray(selectedValues) && selectedValues.includes(item); 

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(` ${item}`));
            container.appendChild(label);
        });
    }

    // Populate all sort page checkbox groups on DOMContentLoaded
    populateCheckboxes('sortVjsCheckboxesTMDB', 'sortVjsTMDB', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesTMDB', 'sortGenresTMDB', GENRE_LIST);
    populateCheckboxes('sortVjsCheckboxesManual', 'sortVjsManual', VJ_LIST);
    populateCheckboxes('sortGenresCheckboxesManual', 'sortGenresManual', GENRE_LIST);
    // These will be populated by loadContentForEditing when needed
    // populateCheckboxes('sortVjsCheckboxesEdit', 'sortVjsEdit', VJ_LIST); 
    // populateCheckboxes('sortGenresCheckboxesEdit', 'sortGenresEdit', GENRE_LIST);


    // --- Helper Functions ---
    function setLoading(button, isLoading) {
        if(button) {
            button.classList.toggle('loading', isLoading);
            button.disabled = isLoading;
        }
    }

    function displayMessage(element, msg, type) {
        if (element) {
            element.textContent = msg;
            element.className = `message ${type}`;
            element.style.display = 'block';
            setTimeout(() => { element.style.display = 'none'; }, 8000);
        }
    }
    
    function generateSlug(text) {
        if (!text) return '';
        return text
            .toString()
            .toLowerCase()
            .trim()
            .replace(/\s+/g, '-')
            .replace(/[^\w\-]+/g, '')
            .replace(/\-\-+/g, '-');
    }

    async function checkForDuplicates(payload, excludeDocId = null) {
        // Check for duplicate TMDB ID if it exists and is a number
        if (payload.tmdbId && typeof payload.tmdbId === 'number') {
            const q = db.collection('movies').where('tmdbId', '==', payload.tmdbId);
            const snapshot = await q.get();
            for (const doc of snapshot.docs) {
                if (doc.id !== excludeDocId) {
                    return { found: true, field: 'TMDB ID' };
                }
            }
        }

        // Check for duplicate slug
        if (payload.slug) {
            const q = db.collection('movies').where('slug', '==', payload.slug);
            const snapshot = await q.get();
            for (const doc of snapshot.docs) {
                if (doc.id !== excludeDocId) {
                    return { found: true, field: 'Unique Text ID (slug)' };
                }
            }
        }
        return { found: false, field: null };
    }

    // User Management specific helper functions
    function hideUserMessage() { userMessageArea.classList.add('hidden'); }
    function clearUserForm() {
        userDocIdInput.value = '';
        userEditNameInput.value = '';
        userEditEmailInput.value = '';
        userEditActivatedSelect.value = 'true';
        userEditExpiresAtInput.value = '';
        userEditFormSection.classList.add('hidden');
        userFormDivider.classList.add('hidden');
        hideUserMessage();
    }
    function formatTimestampForInput(timestamp) {
        if (!timestamp || typeof timestamp.toDate !== 'function') return '';
        const date = timestamp.toDate();
        const timezoneOffset = date.getTimezoneOffset() * 60000;
        const localDate = new Date(date.getTime() - timezoneOffset);
        return localDate.toISOString().slice(0, 16);
    }
    function displayUserMessage(text, type = 'success') {
        userMessageArea.textContent = text;
        userMessageArea.className = `message ${type}`;
        userMessageArea.classList.remove('hidden');
    }

    /**
     * Sends a push notification to all users using Firebase Function.
     * @param {string} title - The title of the notification.
     * @param {string} body - The body/message of the notification.
     * @param {string} [imageUrl=''] - Optional: URL of an image to display in the notification.
     * @param {string} [url=''] - Optional: URL to open when the notification is clicked.
     * @param {HTMLElement} [msgElement=notificationMessage] - The DOM element to display feedback messages.
     * @returns {Promise<boolean>} - True if notification sent successfully, false otherwise.
     */
    async function sendNotification(title, body, imageUrl = '', url = '', msgElement) {
        const payload = {
            title: title,
            body: body,
            imageUrl: imageUrl, // Key name matches backend's expectation
            url: url,
            id: Date.now() // Unique ID for Android to avoid notification overwrites
        };

        try {
            const response = await fetch(firebaseFunctionUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json(); 

            if (response.ok) { // Check if the HTTP response was successful (status 200-299)
                displayMessage(msgElement, 'Notification sent successfully to all subscribed users!', 'success');
                return true;
            } else {
                // If the response indicates an error (e.g., 400, 500)
                displayMessage(msgElement, 'Failed to send notification: ' + (result.error || result.message || 'Unknown error'), 'error');
                console.error('Backend Error Response:', result);
                return false;
            }
        } catch (error) {
            console.error("Fetch API Error:", error);
            displayMessage(msgElement, `A network error occurred or the Firebase Function response was invalid: ${error.message}`, 'error');
            return false;
        }
    }


    // --- Auth and Navigation ---
    auth.onAuthStateChanged(user => {
        loginScreen.style.display = user ? 'none' : 'flex';
        adminPanel.style.display = user ? 'flex' : 'none';
        
        if(user) {
            adminEmailDisplay.textContent = `Logged in as: ${user.email}`;
            // Set initial menu state based on screen size
            if (window.innerWidth >= 769) {
                mainMenu.classList.add('open'); // Open by default on desktop
                mainContentArea.style.marginLeft = '250px';
                menuToggleBtn.style.left = '265px'; // Positioned next to opened menu
            } else {
                mainMenu.classList.remove('open'); // Closed by default on mobile
                mainContentArea.style.marginLeft = '0';
                menuToggleBtn.style.left = '15px'; // Default mobile position
            }
            menuToggleBtn.style.display = 'flex'; // Ensure button is always visible when logged in
            navigateToPage('addContentPage'); // Default page after login
        } else {
            adminEmailDisplay.textContent = '';
            menuToggleBtn.style.display = 'none'; // Hide toggle button when not logged in
        }
    });

    document.getElementById('loginForm').addEventListener('submit', async e => {
        e.preventDefault();
        const btn = e.target.querySelector('button');
        setLoading(btn, true);
        try {
            await auth.signInWithEmailAndPassword(document.getElementById('loginEmail').value, document.getElementById('loginPassword').value);
            displayMessage(loginMessage, '', ''); // Clear any previous login message
        } catch (error) {
            displayMessage(loginMessage, 'Invalid credentials.', 'error');
        } finally {
            setLoading(btn, false);
        }
    });

    logoutBtn.addEventListener('click', () => auth.signOut());
    
    menuToggleBtn.addEventListener('click', () => {
        mainMenu.classList.toggle('open');
        if (mainMenu.classList.contains('open')) {
            mainContentArea.style.marginLeft = '250px';
            menuToggleBtn.style.left = '265px'; // Move button with menu
        } else {
            mainContentArea.style.marginLeft = '0';
            menuToggleBtn.style.left = '15px'; // Move button back
        }
    });

    function navigateToPage(pageId) {
        document.querySelectorAll('.page-container').forEach(p => p.classList.remove('active'));
        const page = document.getElementById(pageId);
        if (page) {
            page.classList.add('active');
            if (pageId === 'bannerPage') {
                const viewBannersTabLink = document.querySelector('.banner-tab-link[data-tab="viewBannersTab"]');
                if (viewBannersTabLink) {
                    viewBannersTabLink.click();
                }
            } else if (pageId === 'allContentPage') { 
                displayAllContent();
            }
            // Reset notification preview when navigating away
            if (pageId !== 'notificationPage') {
                notifTitleInput.value = '';
                notifBodyInput.value = '';
                notifImageUrlInput.value = '';
                notifUrlInput.value = ''; // Clear new URL input
                previewTitle.textContent = 'Notification Title';
                previewBody.textContent = 'Notification body will appear here...';
                previewImage.style.display = 'none';
            }
        }
        document.querySelectorAll('.menu-link').forEach(link => {
            const isActive = link.dataset.page === pageId;
            link.classList.toggle('active', isActive);
            if (isActive) pageTitle.textContent = link.textContent.trim();
        });
        // On mobile, automatically close menu after navigating
        if (window.innerWidth < 769) { 
            mainMenu.classList.remove('open');
            mainContentArea.style.marginLeft = '0'; 
            menuToggleBtn.style.left = '15px'; 
        }
        window.scrollTo(0, 0);
    }
    document.querySelectorAll('.menu-link').forEach(link => {
        // Exclude external links from this navigation logic
        if (!link.hasAttribute('href')) {
             link.addEventListener('click', (e) => {
                e.preventDefault();
                navigateToPage(e.currentTarget.dataset.page);
            });
        }
    });

    // Handle window resize for menu state
    window.addEventListener('resize', () => {
        if (auth.currentUser) { // Only adjust if logged in
            if (window.innerWidth >= 769) {
                mainMenu.classList.add('open');
                mainContentArea.style.marginLeft = '250px';
                menuToggleBtn.style.left = '265px';
            } else {
                mainMenu.classList.remove('open');
                mainContentArea.style.marginLeft = '0';
                menuToggleBtn.style.left = '15px';
            }
        }
    });


    function setupMasterContentTypeToggle(formElement) {
        const primarySelector = formElement.querySelector('.primary-content-type-selector');
        const mediaCategoriesGroup = formElement.querySelector('.media-categories-group');
        const videoUrlGroup = formElement.querySelector('.video-url-group');
        const seriesDataGroup = formElement.querySelector('.series-data-group');
        const genreSelectionGroup = formElement.querySelector('.genre-selection-group'); // Get genre group

        // Define movie and TV series categories
        const movieCategories = [
            "latest_uploads", "Latest-Movies", "most_liked", "animation", "indian", "horror", "comedy", "romance", 
            "adventure", "scifi-fantasy", "action-thriller", "high-school", "nigerian", "send_notification"
        ];
        const tvCategories = [
            "latest_uploads", "most_liked", "upcoming_shows", "western_series", 
            "Latest-TV-Series", "k_dramas", "send_notification"
        ];

        function toggleFields() {
            const primaryType = primarySelector.value;
            const isTV = primaryType === 'tv';

            // Show/hide the entire categories group based on primary type
            if(mediaCategoriesGroup) mediaCategoriesGroup.style.display = 'block'; 

            // Iterate through all checkboxes within the categories group and set their display style
            const categoriesCheckboxes = mediaCategoriesGroup.querySelectorAll('input[type="checkbox"]');
            categoriesCheckboxes.forEach(checkbox => {
                const categoryValue = checkbox.value;
                const parentLabel = checkbox.parentElement; // The <label> element wrapping the checkbox

                if (isTV) {
                    // If TV series is selected, show only TV-specific categories
                    parentLabel.style.display = tvCategories.includes(categoryValue) ? 'flex' : 'none';
                } else {
                    // If Movie is selected, show only movie-specific categories
                    parentLabel.style.display = movieCategories.includes(categoryValue) ? 'flex' : 'none';
                }
            });

            // Genre selection group is always visible, as genres apply to both movies and TV.
            if (genreSelectionGroup) genreSelectionGroup.style.display = 'block'; // Ensure it's always visible

            if(videoUrlGroup) videoUrlGroup.style.display = isTV ? 'none' : 'block';
            if(seriesDataGroup) seriesDataGroup.style.display = isTV ? 'block' : 'none';
        }

        if(primarySelector) {
            primarySelector.addEventListener('change', toggleFields);
            // Call immediately to set initial state based on default selected option
            toggleFields(); 
        }
    }
    setupMasterContentTypeToggle(document.getElementById('addMovieForm'));
    setupMasterContentTypeToggle(document.getElementById('manualAddForm'));
    setupMasterContentTypeToggle(document.getElementById('editContentForm'));


    // --- TMDB Add Form Logic ---
    addMovieForm.addEventListener('submit', async e => {
        e.preventDefault();
        setLoading(addContentBtn, true);
        
        const identifier = document.getElementById('contentIdentifier').value.trim();
        const vjName = document.getElementById('vjName').value.trim();
        const tmdbApiKey = document.getElementById('tmdbApiKey').value;

        if (!vjName) {
            displayMessage(addMessage, 'VJ Name is required.', 'error');
            setLoading(addContentBtn, false);
            return;
        }
        
        if (!identifier) {
            displayMessage(addMessage, 'Content Name or TMDB ID is required.', 'error');
            setLoading(addContentBtn, false);
            return;
        }

        let tmdbData = null;
        let finalApiType = null;
        const isNumericId = /^\d+$/.test(identifier);

        // First, try to fetch as a movie if it's a numeric ID to see if it exists
        // If not found, try as a TV show. This is crucial for handling mixed content types.
        if (isNumericId) {
            try {
                // Try fetching as a movie first
                let response = await fetch(`https://api.themoviedb.org/3/movie/${identifier}?api_key=${tmdbApiKey}`);
                if (response.ok) {
                    tmdbData = await response.json();
                    finalApiType = 'movie';
                } else if (response.status === 404) {
                    // If not found as a movie, try fetching as a TV show
                    response = await fetch(`https://api.themoviedb.org/3/tv/${identifier}?api_key=${tmdbApiKey}`);
                    if (response.ok) {
                        tmdbData = await response.json();
                        finalApiType = 'tv';
                    }
                }
            } catch (err) {
                console.warn("Error checking TMDB by ID (initial attempt):", err);
            }
        } 
        
        // If not a numeric ID, or if numeric ID didn't find anything, perform a search
        if (!tmdbData) {
            try {
                // Determine which search to prioritize based on current form selection
                let preferredSearchType = document.getElementById('primaryContentType').value;
                let searchUrl = `https://api.themoviedb.org/3/search/${preferredSearchType}?api_key=${tmdbApiKey}&query=${encodeURIComponent(identifier)}`;
                let response = await fetch(searchUrl);
                
                if (!response.ok) {
                    console.error(`TMDB Search API error (${preferredSearchType}): ${response.status} ${response.statusText}`);
                    // If preferred type search fails, try the other type
                    preferredSearchType = (preferredSearchType === 'movie') ? 'tv' : 'movie';
                    searchUrl = `https://api.themoviedb.org/3/search/${preferredSearchType}?api_key=${tmdbApiKey}&query=${encodeURIComponent(identifier)}`;
                    response = await fetch(searchUrl);
                    if (!response.ok) {
                        console.error(`TMDB Search API error (fallback ${preferredSearchType}): ${response.status} ${response.statusText}`);
                        throw new Error("TMDB search failed for both movie and TV.");
                    }
                }
                const searchResult = await response.json();
                tmdbData = searchResult.results?.[0] || null;
                if (tmdbData) {
                    finalApiType = preferredSearchType;
                }

            } catch (err) {
                console.error("Error searching TMDB:", err);
            }
        }
        
        if (!tmdbData || !tmdbData.id) {
            displayMessage(addMessage, 'Could not find content on TMDB. Check name/ID or API key.', 'error');
            setLoading(addContentBtn, false);
            return;
        }

        // Now that we have actual TMDB data and its type, update the form's primary content type selector
        // and trigger its change event to ensure correct category checkboxes are visible/hidden.
        const primaryContentTypeSelector = document.getElementById('primaryContentType');
        if (primaryContentTypeSelector.value !== finalApiType) {
            primaryContentTypeSelector.value = finalApiType;
            primaryContentTypeSelector.dispatchEvent(new Event('change')); // Force update categories
        }
        
        const configUrl = `https://api.themoviedb.org/3/configuration?api_key=${tmdbApiKey}`;
        const configResponse = await fetch(configUrl);
        const configData = await configResponse.json();
        const baseImageUrl = configData.images.base_url + configData.images.poster_sizes[3]; // w500 for poster
        const baseBackdropUrl = configData.images.base_url + configData.images.backdrop_sizes[2]; // w780 for backdrop

        tmdbData.fullPosterPath = tmdbData.poster_path ? `${baseImageUrl}${tmdbData.poster_path}` : '';
        tmdbData.fullBackdropPath = tmdbData.backdrop_path ? `${baseBackdropUrl}${tmdbData.backdrop_path}` : '';

        const finalTitle = tmdbData.title || tmdbData.name;
        let payload = {
            title: finalTitle,
            tmdbId: tmdbData.id,
            slug: generateSlug(finalTitle), // Slug based on TMDB title
            posterUrl: tmdbData.fullPosterPath || '',
            backdropUrl: tmdbData.fullBackdropPath || '',
            overview: tmdbData.overview || "N/A",
            vjName: vjName,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            addedBy: auth.currentUser.email,
            sort_vjs: Array.from(document.querySelectorAll('#sortVjsCheckboxesTMDB input[name="sortVjsTMDB"]:checked')).map(cb => cb.value),
            sort_genres: Array.from(document.querySelectorAll('#sortGenresCheckboxesTMDB input[name="sortGenresTMDB"]:checked')).map(cb => cb.value)
        };

        payload.genres = tmdbData.genre_ids || [];

        const sendNotificationChecked = document.querySelector('#contentTypeCheckboxes input[name="contentType"][value="send_notification"]').checked;

        if (finalApiType === 'tv') {
            payload.contentType = 'tv';
            const selectedTypes = Array.from(document.querySelectorAll('#contentTypeCheckboxes input[name="contentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(addMessage, 'Please select at least one category for TV series.', 'error');
                setLoading(addContentBtn, false);
                return;
            }
            payload.type = selectedTypes.filter(type => type !== 'send_notification' && type !== 'Latest-Movies');

            try {
                const seriesDataValue = document.getElementById('seriesData').value;
                if(!seriesDataValue) {
                    displayMessage(addMessage, "Series Data (JSON) cannot be empty for TV series.", 'error');
                    setLoading(addContentBtn, false);
                    return;
                }
                const seriesInfo = JSON.parse(seriesDataValue);

                if (!Array.isArray(seriesInfo) || seriesInfo.some(s => !s.season_number || !Array.isArray(s.episodes))) {
                    throw new Error("Invalid Series Data JSON structure. Expected an array of seasons, each with an 'episodes' array.");
                }
                
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(addMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                    setLoading(addContentBtn, false);
                    return;
                }

                const docRef = await db.collection('movies').add(payload); 
                const seriesDocId = docRef.id;

                for (const season of seriesInfo) {
                    for (const episode of season.episodes) {
                        await db.collection('movies').doc(seriesDocId).collection('episodes').add({
                            season_number: season.season_number,
                            episode_number: episode.episode_number,
                            title: episode.title || `Episode ${episode.episode_number}`,
                            videoUrl: episode.videoUrl,
                            overview: episode.overview || '',
                            air_date: episode.air_date ? firebase.firestore.Timestamp.fromDate(new Date(episode.air_date)) : null,
                            addedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                displayMessage(addMessage, 'TV series and episodes added successfully!', 'success');
                addMovieForm.reset();
                document.querySelectorAll('#sortVjsCheckboxesTMDB input').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortGenresCheckboxesTMDB input').forEach(cb => cb.checked = false);
                
                if (sendNotificationChecked) {
                    const contentUrl = `https://app.streamzonemovies.online/series/${payload.slug}`;
                    await sendNotification(finalTitle, tmdbData.overview || '', tmdbData.fullBackdropPath || '', contentUrl, addMessage);
                }
                document.querySelector('#contentTypeCheckboxes input[name="contentType"][value="send_notification"]').checked = false;

            } catch (err) {
                console.error("Error adding TV series or parsing JSON:", err);
                displayMessage(addMessage, `Error processing TV Series: ${err.message}`, 'error');
            } finally {
                setLoading(addContentBtn, false);
            }

        } else {   
            payload.contentType = 'movie';
            const selectedTypes = Array.from(document.querySelectorAll('#contentTypeCheckboxes input[name="contentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(addMessage, 'Please select at least one category for movies.', 'error');
                setLoading(addContentBtn, false);
                return;
            }
            payload.type = selectedTypes.filter(type => type !== 'send_notification' && type !== 'Latest-TV-Series');
            payload.videoUrl = document.getElementById('videoSourceUrl').value;

            try {
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(addMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                } else {
                    await db.collection('movies').add(payload);
                    displayMessage(addMessage, 'Content added successfully!', 'success');
                    addMovieForm.reset();
                    document.querySelectorAll('#sortVjsCheckboxesTMDB input').forEach(cb => cb.checked = false);
                    document.querySelectorAll('#sortGenresCheckboxesTMDB input').forEach(cb => cb.checked = false);
                    
                    if (sendNotificationChecked) {
                        const contentUrl = `https://app.streamzonemovies.online/movie/${payload.slug}`;
                        await sendNotification(finalTitle, tmdbData.overview || '', tmdbData.fullBackdropPath || '', contentUrl, addMessage);
                    }
                    document.querySelector('#contentTypeCheckboxes input[name="contentType"][value="send_notification"]').checked = false;
                }
            } catch (error) {
                console.error("Error adding document:", error);
                displayMessage(addMessage, `Error: ${error.message}`, 'error');
            } finally {
                setLoading(addContentBtn, false);
            }
        }
    });
    
    // --- Manual Add Form Logic ---
    manualAddForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        setLoading(manualAddBtn, true);
        
        const manualTitle = document.getElementById('manualTitle').value.trim();
        const manualOverview = document.getElementById('manualOverview').value.trim();
        const manualVjName = document.getElementById('manualVjName').value.trim();
        const referenceIdInput = document.getElementById('manualReferenceId').value.trim(); 
        const manualPosterUrl = document.getElementById('manualPosterUrl').value.trim();
        const manualBackdropUrl = document.getElementById('manualBackdropUrl').value.trim();

        if (!manualTitle || !manualVjName || !manualPosterUrl) {
            displayMessage(manualAddMessage, 'Title, VJ Name, and Poster Image URL are required.', 'error');
            setLoading(manualAddBtn, false);
            return;
        }

        let tmdbId = null;
        let slug = generateSlug(manualTitle);

        if (referenceIdInput) {
            if (/^\d+$/.test(referenceIdInput)) {
                tmdbId = Number(referenceIdInput);
                displayMessage(manualAddMessage, `Warning: You entered a numeric ID. This will be saved as a TMDB ID, not a custom slug. Slug will be '${slug}'.`, 'warn');
            } else {
                tmdbId = null;
                slug = generateSlug(referenceIdInput);
            }
        }
        
        // Get selected genres for manual add
        const selectedGenres = Array.from(document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]:checked')).map(cb => cb.value);
        if(selectedGenres.length === 0) { 
            displayMessage(manualAddMessage, 'Please select at least one genre.', 'error');
            setLoading(manualAddBtn, false);
            return;
        }

        // Check if "Send Notification" is ticked
        const sendNotificationChecked = document.querySelector('#manualContentTypeCheckboxes input[name="manualContentType"][value="send_notification"]').checked;

        let payload = {
            title: manualTitle,
            slug: slug, // This will be the custom slug if referenceIdInput was text
            overview: document.getElementById('manualOverview').value,
            posterUrl: manualPosterUrl,
            backdropUrl: manualBackdropUrl,
            vjName: manualVjName,
            tmdbId: tmdbId, // This will be the numeric TMDB ID or null
            genres: selectedGenres, // Add selected genres to payload
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            addedBy: auth.currentUser.email,
            // --- Collect sort_vjs and sort_genres ---
            sort_vjs: Array.from(document.querySelectorAll('#sortVjsCheckboxesManual input[name="sortVjsManual"]:checked')).map(cb => cb.value),
            sort_genres: Array.from(document.querySelectorAll('#sortGenresCheckboxesManual input[name="sortGenresManual"]:checked')).map(cb => cb.value)
        };


        const primaryType = document.getElementById('manualPrimaryContentType').value;
        if (primaryType === 'tv') {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#manualContentTypeCheckboxes input[name="manualContentType"]:checked')).map(cb => cb.value);
            if(selectedTypes.length === 0) {
                displayMessage(manualAddMessage, 'Please select at least one category for TV series.', 'error');
                setLoading(manualAddBtn, false);
                return;
            }
            payload.type = selectedTypes.filter(type => type !== 'send_notification' && type !== 'Latest-Movies'); // Filter out notification and Latest-Movies categories
            try {
                const seriesDataValue = document.getElementById('manualSeriesData').value;
                if(!seriesDataValue) throw new Error("Series Data (JSON) cannot be empty for TV series.");
                const seriesInfo = JSON.parse(seriesDataValue);

                    // Validate seriesInfo structure (basic validation)
                if (!Array.isArray(seriesInfo) || seriesInfo.some(s => !s.season_number || !Array.isArray(s.episodes))) {
                    throw new Error("Invalid Series Data JSON structure. Expected an array of seasons, each with an 'episodes' array.");
                }

                // Check for duplicates before saving anything
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(manualAddMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                    setLoading(manualAddBtn, false);
                    return;
                }

                // Save the main series document
                let seriesDocRef;
                if (payload.slug && !tmdbId) { // Only use slug as doc ID if it's a custom text slug (not TMDB ID)
                    seriesDocRef = db.collection('movies').doc(payload.slug);
                    await seriesDocRef.set(payload);
                } else {
                    // Let Firestore generate an ID or use auto-generated ID for TMDB ID entries
                    seriesDocRef = await db.collection('movies').add(payload);
                }
                const seriesDocId = seriesDocRef.id;

                // Save episodes to a subcollection
                for (const season of seriesInfo) {
                    for (const episode of season.episodes) {
                        await db.collection('movies').doc(seriesDocId).collection('episodes').add({
                            season_number: season.season_number,
                            episode_number: episode.episode_number,
                            title: episode.title || `Episode ${episode.episode_number}`,
                            videoUrl: episode.videoUrl,
                            overview: episode.overview || '',
                            air_date: episode.air_date ? firebase.firestore.Timestamp.fromDate(new Date(episode.air_date)) : null,
                            addedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                displayMessage(manualAddMessage, 'TV series and episodes added successfully!', 'success');
                manualAddForm.reset();
                document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]').forEach(cb => cb.checked = false);
                // Reset new sort checkboxes after successful add
                document.querySelectorAll('#sortVjsCheckboxesManual input').forEach(cb => cb.checked = false);
                document.querySelectorAll('#sortGenresCheckboxesManual input').forEach(cb => cb.checked = false);
                
                // Automatically send notification if checked
                if (sendNotificationChecked) {
                    const contentUrl = `https://app.streamzonemovies.online/series/${payload.slug}`; // Example URL
                    await sendNotification(manualTitle, manualOverview, manualBackdropUrl, contentUrl, manualAddMessage);
                }
                document.querySelector('#manualContentTypeCheckboxes input[name="manualContentType"][value="send_notification"]').checked = false; // Uncheck notification

            } catch (err) {
                console.error("Error adding TV series manually or parsing JSON:", err);
                displayMessage(manualAddMessage, `Error processing TV Series: ${err.message}`, 'error');
            } finally {
                setLoading(manualAddBtn, false);
            }

        } else {
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#manualContentTypeCheckboxes input[name="manualContentType"]:checked')).map(cb => cb.value);
            if (selectedTypes.length === 0) {
                displayMessage(manualAddMessage, 'Please select at least one category for movies.', 'error');
                setLoading(manualAddBtn, false);
                return;
            }
            payload.type = selectedTypes.filter(type => type !== 'send_notification' && type !== 'Latest-TV-Series'); // Filter out notification and Latest-TV-Series categories
            payload.videoUrl = document.getElementById('manualVideoSourceUrl').value;

            try {
                const duplicateCheck = await checkForDuplicates(payload);
                if (duplicateCheck.found) {
                    displayMessage(manualAddMessage, `Duplicate found by ${duplicateCheck.field}. Addition denied.`, 'error');
                } else {
                    await db.collection('movies').add(payload);
                    displayMessage(manualAddMessage, 'Content added successfully!', 'success');
                    manualAddForm.reset();
                    // After successful add, reset genre and new sort checkboxes
                    document.querySelectorAll('#manualGenreCheckboxes input[name="manualGenre"]').forEach(cb => cb.checked = false);
                    document.querySelectorAll('#sortVjsCheckboxesManual input').forEach(cb => cb.checked = false);
                    document.querySelectorAll('#sortGenresCheckboxesManual input').forEach(cb => cb.checked = false);
                    
                    // Automatically send notification if checked
                    if (sendNotificationChecked) {
                        const contentUrl = `https://app.streamzonemovies.online/movie/${payload.slug}`; // Example URL
                        await sendNotification(manualTitle, manualOverview, manualBackdropUrl, contentUrl, manualAddMessage);
                    }
                    document.querySelector('#manualContentTypeCheckboxes input[name="manualContentType"][value="send_notification"]').checked = false; // Uncheck notification
                }
            } catch (error) {
                console.error("Error adding document manually:", error);
                displayMessage(manualAddMessage, `Error: ${error.message}`, 'error');
            } finally {
                setLoading(manualAddBtn, false);
            }
        }
    });

    // --- Manage & Edit Content Logic ---
    searchManageBtn.addEventListener('click', async () => {
        setLoading(searchManageBtn, true);
        manageSearchResults.innerHTML = '';
        selectedMoviesForDeletion.clear();
        confirmDeleteBtn.style.display = 'none';
        const term = document.getElementById('manageContentIdentifier').value.trim();
        if (!term) {
            displayMessage(manageMessage, 'Enter a name or ID to search.', 'error');
            setLoading(searchManageBtn, false);
            return;
        }
        
        try {
            let docs = [];
            const lowerCaseTerm = term.toLowerCase();
            
            // Search only in the primary db
            const snapshot = await db.collection('movies').get(); 
            snapshot.forEach(doc => {
                const data = doc.data();
                // Check if TMDB ID matches (numeric search)
                if (data.tmdbId && /^\d+$/.test(term) && data.tmdbId === Number(term)) {
                    docs.push({ id: doc.id, ...data });
                } 
                // Check if title or slug includes the term (case-insensitive)
                else if (
                    (data.title && data.title.toLowerCase().includes(lowerCaseTerm)) || 
                    (data.slug && data.slug.toLowerCase().includes(lowerCaseTerm))
                ) {
                    docs.push({ id: doc.id, ...data });
                }
            });

            if(docs.length === 0) {
                displayMessage(manageMessage, 'No content found matching your search.', 'info');
            } else {
                docs.forEach(item => {
                    manageSearchResults.innerHTML += `
                        <div class="result-item">
                            <span><strong>${item.title}</strong> (ID: ${item.tmdbId || item.slug || 'N/A'}) - Type: ${item.contentType || 'N/A'}</span>
                            <div class="result-item-actions">
                                <button class="action-btn edit" data-id="${item.id}">Edit</button>
                                <button class="action-btn select-delete" data-id="${item.id}">Select</button>
                            </div>
                        </div>
                    `;
                });
                displayMessage(manageMessage, `Found ${docs.length} item(s).`, 'success');
            }
        } catch (err) {
            console.error("Error searching content:", err);
            displayMessage(manageMessage, `Error searching content: ${err.message}`, 'error');
        } finally {
            setLoading(searchManageBtn, false);
        }
    });
    
    manageSearchResults.addEventListener('click', e => {
        if(e.target.matches('.select-delete')){
            const btn = e.target;
            const id = btn.dataset.id;
            if(selectedMoviesForDeletion.has(id)){
                selectedMoviesForDeletion.delete(id);
                btn.classList.remove('selected');
                btn.textContent = 'Select';
            } else {
                selectedMoviesForDeletion.add(id);
                btn.classList.add('selected');
                btn.textContent = 'Selected';
            }
            confirmDeleteBtn.style.display = selectedMoviesForDeletion.size > 0 ? 'block' : 'none';
            confirmDeleteBtn.textContent = `Delete Selected (${selectedMoviesForDeletion.size})`;
        }
        if (e.target.matches('.action-btn.edit')) {
            const docId = e.target.dataset.id;
            loadContentForEditing(docId);
        }
    });
    
    confirmDeleteBtn.addEventListener('click', async () => {
        if(confirm(`Are you sure you want to delete ${selectedMoviesForDeletion.size} item(s)? This action cannot be undone.`)){
            setLoading(confirmDeleteBtn, true);
            const deletePromises = [];
            selectedMoviesForDeletion.forEach(id => {
                deletePromises.push(db.collection('movies').doc(id).delete());
            });

            try {
                await Promise.all(deletePromises);
                displayMessage(manageMessage, `Deleted ${selectedMoviesForDeletion.size} items successfully.`, 'success');
                manageSearchResults.innerHTML = ''; // Clear results after deletion
                confirmDeleteBtn.style.display = 'none';
                selectedMoviesForDeletion.clear();
            } catch(err){
                console.error("Error deleting content:", err);
                displayMessage(manageMessage, `Error deleting content: ${err.message}`, 'error');
            } finally {
                setLoading(confirmDeleteBtn, false);
            }
        }
    });

    // --- Edit Content Logic ---
    async function loadContentForEditing(id) {
        try {
            const docRef = db.collection('movies').doc(id);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                displayMessage(manageMessage, 'Content not found or already deleted.', 'error');
                return;
            }
            const data = docSnap.data();
            
            editContentForm.reset();
            document.getElementById('editDocId').value = docSnap.id;
            // No need for projectId dataset as we are only using one project

            document.getElementById('editTitle').value = data.title || '';
            document.getElementById('editOverview').value = data.overview || '';
            document.getElementById('editPosterUrl').value = data.posterUrl || '';
            document.getElementById('editBackdropUrl').value = data.backdropUrl || ''; // Populate backdrop URL
            document.getElementById('editVjName').value = data.vjName || '';
            
            // Map the `movie` and `tv` values back to `latest_movies` and `latest_tv_shows` for display if needed
            const primaryTypeSelector = document.getElementById('editPrimaryContentType');
            primaryTypeSelector.value = data.contentType === 'tv' ? 'tv' : 'movie';
            primaryTypeSelector.dispatchEvent(new Event('change')); // Trigger visibility logic

            // Populate "Reference ID" with tmdbId if present, otherwise with slug if it's not generated from title
            const isSlugFromTitle = generateSlug(data.title || '') === data.slug;
            document.getElementById('editReferenceId').value = data.tmdbId || (!isSlugFromTitle && data.slug ? data.slug : '');


            // Uncheck all category checkboxes first
            document.querySelectorAll('#editContentTypeCheckboxes input').forEach(cb => {
                cb.checked = false; 
            });

            // Set checked status based on `data.type`
            if (Array.isArray(data.type)) {
                data.type.forEach(typeValue => {
                    // Adjust typeValue for the admin panel's specific display values
                    let displayValue = typeValue;
                    if (typeValue === 'movie') displayValue = 'Latest-Movies'; // Renamed for display
                    if (typeValue === 'tv') displayValue = 'Latest-TV-Series'; // Renamed for display
                    if (typeValue === 'popular') displayValue = 'latest_uploads'; // Map 'popular' back to 'latest_uploads'

                    const checkbox = document.querySelector(`#editContentTypeCheckboxes input[value="${displayValue}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            // Also check the "Send Notification" checkbox if the content has that type
            if (data.type && data.type.includes('send_notification')) {
                document.querySelector('#editContentTypeCheckboxes input[name="editContentType"][value="send_notification"]').checked = true;
            }

            // Uncheck all genre checkboxes first
            document.querySelectorAll('#editGenreCheckboxes input[name="editGenre"]').forEach(cb => {
                cb.checked = false;
            });
            // Set checked status for genres based on `data.genres`
            if (Array.isArray(data.genres)) {
                data.genres.forEach(genreValue => {
                    const checkbox = document.querySelector(`#editGenreCheckboxes input[value="${genreValue}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            
            // NEW: Populate sort_vjs and sort_genres checkboxes from fetched data
            populateCheckboxes('sortVjsCheckboxesEdit', 'sortVjsEdit', VJ_LIST, data.sort_vjs);
            populateCheckboxes('sortGenresCheckboxesEdit', 'sortGenresEdit', GENRE_LIST, data.sort_genres);
            
            if (data.contentType === 'movie') {
                document.getElementById('editVideoSourceUrl').value = data.videoUrl || '';
                // Clear series data if it was previously a TV series
                document.getElementById('editSeriesData').value = ''; 
            } else if (data.contentType === 'tv') {
                // Fetch episodes for TV series
                const episodesSnapshot = await db.collection('movies').doc(id).collection('episodes').get();
                const seasonsData = {};

                episodesSnapshot.forEach(episodeDoc => {
                    const episodeData = episodeDoc.data();
                    const seasonNum = episodeData.season_number;
                    if (!seasonsData[seasonNum]) {
                        seasonsData[seasonNum] = { season_number: seasonNum, episodes: [] };
                    }
                    seasonsData[seasonNum].episodes.push({
                        episode_number: episodeData.episode_number,
                        title: episodeData.title || `Episode ${episodeData.episode_number}`,
                        videoUrl: episodeData.videoUrl,
                        overview: episodeData.overview || '',
                        air_date: episodeData.air_date ? episodeData.air_date.toDate().toISOString().slice(0, 10) : ''
                    });
                });

                // Convert to array and sort by season and then episode number
                const formattedSeriesInfo = Object.values(seasonsData).sort((a, b) => a.season_number - b.season_number);
                formattedSeriesInfo.forEach(season => {
                    season.episodes.sort((a, b) => a.episode_number - b.episode_number);
                });

                document.getElementById('editSeriesData').value = JSON.stringify(formattedSeriesInfo, null, 2);
                // Clear video URL if it was previously a movie
                document.getElementById('editVideoSourceUrl').value = ''; 
            }

            navigateToPage('editContentPage');
        } catch (err) {
            console.error("Error loading content for editing:", err);
            displayMessage(manageMessage, `Error loading content: ${err.message}`, 'error');
        }
    }

    editContentForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        setLoading(updateContentBtn, true);
        const docId = document.getElementById('editDocId').value;

        if (!docId) {
            displayMessage(editMessage, 'No document ID found. Cannot update.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }
        const editTitle = document.getElementById('editTitle').value.trim();
        const editOverview = document.getElementById('editOverview').value.trim();
        const editVjName = document.getElementById('editVjName').value.trim();
        const referenceIdInput = document.getElementById('editReferenceId').value.trim();  
        const editPosterUrl = document.getElementById('editPosterUrl').value.trim();
        const editBackdropUrl = document.getElementById('editBackdropUrl').value.trim(); // Get backdrop URL

        if (!editTitle || !editVjName || !editPosterUrl) { // Poster URL is now required
            displayMessage(editMessage, 'Title, VJ Name, and Poster Image URL are required.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }

        let tmdbId = null;
        let slug = generateSlug(editTitle);

        if(referenceIdInput) {
            if(/^\d+$/.test(referenceIdInput)) {
                tmdbId = Number(referenceIdInput);
            } else {
                tmdbId = null;
                slug = generateSlug(referenceIdInput);
            }
        }
        
        // Get selected genres from the edit form
        const selectedGenres = Array.from(document.querySelectorAll('#editGenreCheckboxes input[name="editGenre"]:checked')).map(cb => cb.value);
        if(selectedGenres.length === 0) { 
            displayMessage(editMessage, 'Please select at least one genre.', 'error');
            setLoading(updateContentBtn, false);
            return;
        }

        // Check if "Send Notification" is ticked
        const sendNotificationChecked = document.querySelector('#editContentTypeCheckboxes input[name="editContentType"][value="send_notification"]').checked;


        let payload = {
            title: editTitle,
            slug: slug,
            overview: editOverview,
            posterUrl: editPosterUrl,
            backdropUrl: editBackdropUrl,
            vjName: editVjName,
            tmdbId: tmdbId,
            genres: selectedGenres, // Add selected genres to payload
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            // --- Collect updated sort_vjs and sort_genres ---
            sort_vjs: Array.from(document.querySelectorAll('#sortVjsCheckboxesEdit input[name="sortVjsEdit"]:checked')).map(cb => cb.value),
            sort_genres: Array.from(document.querySelectorAll('#sortGenresCheckboxesEdit input[name="sortGenresEdit"]:checked')).map(cb => cb.value)
        };

        const primaryType = document.getElementById('editPrimaryContentType').value;
        if (primaryType === 'tv') {
            payload.contentType = 'tv';
            // For TV, 'type' will store the selected TV categories
            const selectedTypes = Array.from(document.querySelectorAll('#editContentTypeCheckboxes input[name="editContentType"]:checked')).map(cb => {
                // Map the displayed values back to original stored values
                if (cb.value === 'Latest-Movies') return 'movie'; // Map back to 'movie'
                if (cb.value === 'Latest-TV-Series') return 'tv'; // Map back to 'tv'
                if (cb.value === 'latest_uploads') return 'popular'; // Map 'latest_uploads' to 'popular'
                return cb.value; // Return as is for other values
            });
            if (selectedTypes.length === 0) {
                    displayMessage(editMessage, 'Please select at least one category for TV series.', 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
            payload.type = selectedTypes.filter(type => type !== 'send_notification' && type !== 'Latest-Movies'); // Filter out notification and Latest-Movies categories
            
            try {
                const seriesDataValue = document.getElementById('editSeriesData').value;
                if(!seriesDataValue) throw new Error("Series Data (JSON) cannot be empty for TV series.");
                const seriesInfo = JSON.parse(seriesDataValue);

                // Validate seriesInfo structure (basic validation)
                if (!Array.isArray(seriesInfo) || seriesInfo.some(s => !s.season_number || !Array.isArray(s.episodes))) {
                    throw new Error("Invalid Series Data JSON structure. Expected an array of seasons, each with an 'episodes' array.");
                }
                
                // Remove videoUrl and seriesInfo field (if it exists) from main document
                payload.videoUrl = firebase.firestore.FieldValue.delete(); 
                if (payload.seriesInfo) { // Check if seriesInfo exists before trying to delete it
                    payload.seriesInfo = firebase.firestore.FieldValue.delete();
                }

                const duplicateCheck = await checkForDuplicates(payload, docId);  
                if (duplicateCheck.found) {
                    displayMessage(editMessage, `Update failed. Another entry exists with this ${duplicateCheck.field}.`, 'error');
                    setLoading(updateContentBtn, false);
                    return;
                }

                // Update main series document
                await db.collection('movies').doc(docId).update(payload);

                // Delete existing episodes subcollection and re-add them
                const episodesCollectionRef = db.collection('movies').doc(docId).collection('episodes');
                const existingEpisodesSnapshot = await episodesCollectionRef.get();
                const deleteEpisodePromises = [];
                existingEpisodesSnapshot.forEach(episodeDoc => {
                    deleteEpisodePromises.push(episodesCollectionRef.doc(episodeDoc.id).delete());
                });
                await Promise.all(deleteEpisodePromises);

                // Add new episodes
                for (const season of seriesInfo) {
                    for (const episode of season.episodes) {
                        await episodesCollectionRef.add({
                            season_number: episode.season_number || season.season_number, // Prefer episode's own season_number if present
                            episode_number: episode.episode_number,
                            title: episode.title || `Episode ${episode.episode_number}`,
                            videoUrl: episode.videoUrl,
                            overview: episode.overview || '',
                            air_date: episode.air_date ? firebase.firestore.Timestamp.fromDate(new Date(episode.air_date)) : null,
                            addedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                displayMessage(editMessage, 'TV series and episodes updated successfully!', 'success');
                setTimeout(() => navigateToPage('allContentPage'), 2000);
                
                // Automatically send notification if checked
                if (sendNotificationChecked) {
                    const contentUrl = `https://app.streamzonemovies.online/series/${payload.slug}`; // Example URL
                    await sendNotification(editTitle, editOverview, editBackdropUrl, contentUrl, editMessage);
                }
                document.querySelector('#editContentTypeCheckboxes input[name="editContentType"][value="send_notification"]').checked = false; // Uncheck notification

            } catch (err) {
                    displayMessage(editMessage, `Error updating TV Series: ${err.message}`, 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
        } else {   
            payload.contentType = 'movie';
            // For movies, 'type' will store the selected movie categories
            const selectedTypes = Array.from(document.querySelectorAll('#editContentTypeCheckboxes input[name="editContentType"]:checked')).map(cb => {
                // Map the displayed values back to original stored values
                if (cb.value === 'Latest-Movies') return 'movie';
                if (cb.value === 'Latest-TV-Series') return 'tv';
                if (cb.value === 'latest_uploads') return 'popular';
                return cb.value; // Return as is for other values
            });
            if (selectedTypes.length === 0) {
                    displayMessage(editMessage, 'Please select at least one category for movies.', 'error');
                    setLoading(updateContentBtn, false);
                    return;
            }
            payload.type = selectedTypes.filter(type => type !== 'send_notification' && type !== 'Latest-TV-Series'); // Filter out notification and Latest-TV-Series categories
            payload.videoUrl = document.getElementById('editVideoSourceUrl').value;
            payload.seriesInfo = firebase.firestore.FieldValue.delete(); // Ensure seriesInfo is removed for movies

            const duplicateCheck = await checkForDuplicates(payload, docId);  
            if (duplicateCheck.found) {
                displayMessage(editMessage, `Update failed. Another entry exists with this ${duplicateCheck.field}.`, 'error');
                setLoading(updateContentBtn, false);
                return;
            }

            await db.collection('movies').doc(docId).update(payload);
            displayMessage(editMessage, 'Content updated successfully!', 'success');
            setTimeout(() => navigateToPage('allContentPage'), 2000);
            
            // Automatically send notification if checked
            if (sendNotificationChecked) {
                const contentUrl = `https://app.streamzonemovies.online/movie/${payload.slug}`; // Example URL
                await sendNotification(editTitle, editOverview, editBackdropUrl, contentUrl, editMessage);
            }
            document.querySelector('#editContentTypeCheckboxes input[name="editContentType"][value="send_notification"]').checked = false; // Uncheck notification
        }
        
        try {
            // All updates happen within the if/else blocks now.
            // No longer pre-filling notification form or navigating; just sending automatically.
        } catch (error) {
            console.error("Update Error:", error);
            displayMessage(editMessage, `Update Error: ${error.message}`, 'error');
        } finally {
            setLoading(updateContentBtn, false);
        }
    });

    cancelEditBtn.addEventListener('click', () => { navigateToPage('allContentPage'); }); 

    // --- All Content Page Logic ---
    async function displayAllContent() {
        allContentContainer.innerHTML = '<div class="message info" style="display:block;">Loading all content...</div>';
        selectedAllContentForDeletion.clear();
        updateDeleteSelectedButton(); 
        
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        
        // Adjust button text and behavior based on filter
        if (filterValue === 'all' || filterValue === 'Latest-Movies' || filterValue === 'Latest-TV-Series') {
            deleteSelectedAllContentBtn.textContent = `Delete Selected Content (${selectedAllContentForDeletion.size})`;
            deleteSelectedAllContentBtn.classList.remove('remove-from-category-mode'); // Optional: add a class for styling
            deleteSelectedAllContentBtn.dataset.deleteMode = 'permanent';
        } else {
            deleteSelectedAllContentBtn.textContent = `Remove Selected from ${filterText} (${selectedAllContentForDeletion.size})`;
            deleteSelectedAllContentBtn.classList.add('remove-from-category-mode'); // Optional: add a class for styling
            deleteSelectedAllContentBtn.dataset.deleteMode = 'category-removal';
        }

        try {
            let docsToDisplay = [];

            let query = db.collection('movies').orderBy('createdAt', 'desc');
            
            if (filterValue !== 'all') {
                if (filterValue === 'Latest-Movies') {
                    // For "Latest Movies", ensure contentType is 'movie' AND it has 'movie' in its type array
                    query = query.where('contentType', '==', 'movie').where('type', 'array-contains', 'movie');
                } else if (filterValue === 'Latest-TV-Series') {
                    // For "Latest TV Series", ensure contentType is 'tv' AND it has 'tv' in its type array
                    query = query.where('contentType', '==', 'tv').where('type', 'array-contains', 'tv');
                } else {
                    // For other specific categories (e.g., 'animation', 'horror'), query the 'type' array
                    // Map filterValue back to the actual stored type value if it's a renamed one
                    let actualFilterValue = filterValue;
                    if (filterValue === 'latest_uploads') actualFilterValue = 'popular'; // Map 'latest_uploads' to 'popular'

                    query = query.where('type', 'array-contains', actualFilterValue);
                }
            }
            const snapshot = await query.get();
            snapshot.forEach(doc => {
                docsToDisplay.push({ id: doc.id, ...doc.data() });
            });
            
            if (docsToDisplay.length === 0) {
                allContentContainer.innerHTML = '';
                displayMessage(allContentMessage, 'No content found.', 'info');
                return;
            }
            
            allContentContainer.innerHTML = '';
            docsToDisplay.forEach(item => {
                const imageUrl = item.posterUrl || 'https://placehold.co/500x750/333/eee?text=No+Poster'; 
                const title = item.title || 'Untitled';
                const vjName = item.vjName || 'Unknown VJ';
                // Display TMDB ID or custom slug
                const contentId = item.tmdbId || item.slug || 'N/A'; 

                // Determine button text based on filterType
                const individualButtonText = (filterValue === 'all' || filterValue === 'Latest-Movies' || filterValue === 'Latest-TV-Series') ? 'Delete' : 'Remove from Category';
                const individualButtonClass = (filterValue === 'all' || filterValue === 'Latest-Movies' || filterValue === 'Latest-TV-Series') ? 'delete' : 'remove-from-category';

                const cardHtml = `
                    <div class="content-card">
                        <input type="checkbox" class="select-card-checkbox" data-id="${item.id}">
                        <img src="${imageUrl}" alt="${title}" onerror="this.onerror=null; this.src='/Upload/Logo.png';">
                        <div class="content-card-content">
                            <h3>${title}</h3>
                            <p class="vj-name">VJ: ${vjName}</p>
                            <p class="content-id-display">ID: ${contentId}</p>
                            <div class="content-card-actions">
                                <button class="action-btn edit" data-id="${item.id}">Edit</button>
                                <button class="action-btn ${individualButtonClass}" data-id="${item.id}">${individualButtonText}</button>
                            </div>
                        </div>
                    </div>
                `;
                allContentContainer.insertAdjacentHTML('beforeend', cardHtml);
            });
            displayMessage(allContentMessage, `Found ${docsToDisplay.length} item(s).`, 'success');

        } catch (err) {
            console.error("Error displaying all content:", err);
            allContentContainer.innerHTML = '';
            displayMessage(allContentMessage, `Error: ${err.message}`, 'error');
        }
    }

    function updateDeleteSelectedButton() {
        selectedAllContentCount.textContent = selectedAllContentForDeletion.size;
        deleteSelectedAllContentBtn.style.display = selectedAllContentForDeletion.size > 0 ? 'block' : 'none';
        
        // Update the text on the main button as well
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        if (filterValue === 'all' || filterValue === 'Latest-Movies' || filterValue === 'Latest-TV-Series') {
            deleteSelectedAllContentBtn.textContent = `Delete Selected Content (${selectedAllContentForDeletion.size})`;
        } else {
            deleteSelectedAllContentBtn.textContent = `Remove Selected from ${filterText} (${selectedAllContentForDeletion.size})`;
        }
    }

    allContentFilter.addEventListener('change', displayAllContent);

    // Function to remove a specific category from a content item
    async function removeContentFromCategory(docId, categoryToRemove) {
        const docRef = db.collection('movies').doc(docId);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            const currentTypes = docSnap.data().type || [];
            // Map the categoryToRemove back to its original stored value if it was a renamed display value
            let actualCategoryToRemove = categoryToRemove;
            if (categoryToRemove === 'Latest-Movies') actualCategoryToRemove = 'movie';
            if (categoryToRemove === 'Latest-TV-Series') actualCategoryToRemove = 'tv';
            if (categoryToRemove === 'latest_uploads') actualCategoryToRemove = 'popular';

            const updatedTypes = currentTypes.filter(type => type !== actualCategoryToRemove);
            
            await docRef.update({
                type: updatedTypes,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            return true;
        }
        return false;
    }

    allContentContainer.addEventListener('click', async e => {
        const target = e.target;
        // For checkbox or buttons, get the docId from dataset
        const cardElement = target.closest('.content-card');
        const docId = cardElement?.querySelector('.select-card-checkbox')?.dataset.id || target.dataset.id;
        
        if (!docId) return; // Exit if no id found

        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;

        if (target.matches('.select-card-checkbox')) {
            if (target.checked) {
                selectedAllContentForDeletion.add(docId);
            } else {
                selectedAllContentForDeletion.delete(docId);
            }
            updateDeleteSelectedButton();
        } else if (target.matches('.action-btn.edit')) {
            loadContentForEditing(docId);
        } else if (target.matches('.action-btn.delete')) { // This is for permanent delete
            if (confirm(`Are you sure you want to delete this content permanently? This cannot be undone.`)) {
                setLoading(target, true);
                try {
                    await db.collection('movies').doc(docId).delete();
                    displayMessage(allContentMessage, 'Content deleted successfully!', 'success');
                    selectedAllContentForDeletion.delete(docId); 
                    updateDeleteSelectedButton();
                    displayAllContent(); 
                } catch (err) {
                    console.error("Error deleting content:", err);
                    displayMessage(allContentMessage, `Error deleting content: ${err.message}`, 'error');
                } finally {
                    setLoading(target, false);
                }
            }
        } else if (target.matches('.action-btn.remove-from-category')) { // This is for category removal
            if (confirm(`Are you sure you want to remove this content from the "${filterText}" category? It will not be permanently deleted.`)) {
                setLoading(target, true);
                try {
                    const success = await removeContentFromCategory(docId, filterValue);
                    if (success) {
                        displayMessage(allContentMessage, `Content removed from "${filterText}" category successfully!`, 'success');
                        selectedAllContentForDeletion.delete(docId); 
                        updateDeleteSelectedButton();
                        displayAllContent(); // Re-display to update list
                    } else {
                        displayMessage(allContentMessage, 'Failed to remove content from category: Document not found.', 'error');
                    }
                } catch (err) {
                    console.error("Error removing from category:", err);
                    displayMessage(allContentMessage, `Error removing from category: ${err.message}`, 'error');
                } finally {
                    setLoading(target, false);
                }
            }
        }
    });

    deleteSelectedAllContentBtn.addEventListener('click', async () => {
        if (selectedAllContentForDeletion.size === 0) {
            displayMessage(allContentMessage, 'No content selected for action.', 'info');
            return;
        }
        
        const filterValue = allContentFilter.value;
        const filterText = allContentFilter.options[allContentFilter.selectedIndex].text;
        const isPermanentDelete = (filterValue === 'all' || filterValue === 'Latest-Movies' || filterValue === 'Latest-TV-Series');

        let confirmationMessage;
        let successMessage;
        let errorMessage;
        let actionPromises = [];

        if (isPermanentDelete) {
            confirmationMessage = `Are you sure you want to delete ${selectedAllContentForDeletion.size} item(s) permanently? This action cannot be undone.`;
            successMessage = `Deleted ${selectedAllContentForDeletion.size} items successfully.`;
            errorMessage = `Error deleting selected content: `;
        } else {
            confirmationMessage = `Are you sure you want to remove ${selectedAllContentForDeletion.size} item(s) from the "${filterText}" category? They will not be permanently deleted.`;
            successMessage = `Removed ${selectedAllContentForDeletion.size} items from "${filterText}" category successfully.`;
            errorMessage = `Error removing selected content from category: `;
        }

        if (confirm(confirmationMessage)) {
            setLoading(deleteSelectedAllContentBtn, true);
            
            selectedAllContentForDeletion.forEach(id => {
                if (isPermanentDelete) {
                    actionPromises.push(db.collection('movies').doc(id).delete());
                } else {
                    actionPromises.push(removeContentFromCategory(id, filterValue));
                }
            });

            try {
                await Promise.all(actionPromises);
                displayMessage(allContentMessage, successMessage, 'success');
                selectedAllContentForDeletion.clear(); 
                updateDeleteSelectedButton();
                displayAllContent(); 
            } catch (err) {
                console.error(errorMessage, err);
                displayMessage(allContentMessage, `${errorMessage}${err.message}`, 'error');
            } finally {
                setLoading(deleteSelectedAllContentBtn, false);
            }
        }
    });


    // --- Banner logic ---
    async function displayAllBanners() {
        allBannersContainer.innerHTML = '<div class="message info" style="display:block;">Loading banners...</div>';
        try {
            const snapshot = await db.collection('banners').orderBy('updatedAt', 'desc').limit(10).get();
            if (snapshot.empty) {
                allBannersContainer.innerHTML = '';
                displayMessage(viewBannersMessage, 'No banners found. Add one from the "Add/Edit Banner" tab.', 'info');
                return;
            }
            allBannersContainer.innerHTML = '';
            snapshot.forEach(doc => {
                const banner = doc.data();
                const card = `
                    <div class="banner-card">
                        <img src="${banner.imageUrl}" alt="${banner.title}" onerror="this.src='https://placehold.co/500x300/333/eee?text=No+Image';">
                        <div class="banner-card-content">
                            <h3>${banner.title}</h3>
                            <p>${(banner.description || 'No description available.').substring(0, 100)}...</p>
                            <div class="banner-card-actions">
                                <button class="action-btn edit" data-id="${doc.id}">Edit</button>
                                <button class="action-btn delete" data-id="${doc.id}">Delete</button>
                            </div>
                        </div>
                    </div>
                `;
                allBannersContainer.insertAdjacentHTML('beforeend', card);
            });
            displayMessage(viewBannersMessage, `Found ${snapshot.size} banner(s).`, 'success');
        } catch (err) {
            console.error("Error displaying banners:", err);
            allBannersContainer.innerHTML = '';
            displayMessage(viewBannersMessage, `Error: ${err.message}`, 'error');
        }
    }

    bannerNavTabs.addEventListener('click', e => {
        if (e.target.matches('.banner-tab-link')) {
            const tabId = e.target.dataset.tab;
            document.querySelectorAll('.banner-tab-link').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            document.querySelectorAll('.banner-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            if (tabId === 'viewBannersTab') {
                displayAllBanners();
            }
        }
    });

    allBannersContainer.addEventListener('click', async e => {
        const target = e.target;
        if (target.matches('.action-btn.delete')) {
            const docId = target.dataset.id;
            if (confirm('Are you sure you want to delete this banner permanently?')) {
                setLoading(target, true);
                try {
                    await db.collection('banners').doc(docId).delete();
                    displayMessage(viewBannersMessage, 'Banner deleted successfully!', 'success');
                    await displayAllBanners();
                }  catch (err) { // More specific error handling
                    console.error("Error deleting banner:", err);
                    displayMessage(viewBannersMessage, `Error deleting banner: ${err.message}`, 'error');
                    setLoading(target, false);
                }
            }
        }
        if (target.matches('.action-btn.edit')) {
            await loadBannerForEditing(target.dataset.id);
        }
    });

    addEditBannerForm.addEventListener('submit', async e => {
        e.preventDefault();
        setLoading(saveBannerBtn, true);
        const id = bannerDocId.value;
        const data = {
            title: document.getElementById('bannerTitle').value.trim(),
            imageUrl: document.getElementById('bannerImageUrl').value,
            description: document.getElementById('bannerDescription').value,
            link: document.getElementById('bannerLink').value,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        if (!data.title || !data.imageUrl || !data.link) {
            displayMessage(addBannerMessage, 'Title, Image URL, and Link are required for banners.', 'error');
            setLoading(saveBannerBtn, false);
            return;
        }

        try {
            if (id) {
                await db.collection('banners').doc(id).update(data);
            } else {
                await db.collection('banners').add({ ...data, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            }
            displayMessage(addBannerMessage, 'Banner saved successfully!', 'success');
            resetBannerForm();
            document.querySelector('.banner-tab-link[data-tab="viewBannersTab"]').click(); 
        } catch (err) {
            console.error("Error saving banner:", err);
            displayMessage(addBannerMessage, `Error saving banner: ${err.message}`, 'error');
        } finally {
            setLoading(saveBannerBtn, false);
        }
    });

    function resetBannerForm() {
        addEditBannerForm.reset();
        bannerDocId.value = '';
        bannerFormTitle.textContent = 'Add New Banner';
        saveBannerBtn.textContent = 'Save Banner';
        cancelEditBannerBtn.style.display = 'none';
        displayMessage(addBannerMessage, '', ''); 
    }
    cancelEditBannerBtn.addEventListener('click', resetBannerForm);

    async function loadBannerForEditing(id) {
        try {
            const doc = await db.collection('banners').doc(id).get();
            if (doc.exists) {
                const d = doc.data();
                bannerDocId.value = id;
                document.getElementById('bannerTitle').value = d.title || '';
                document.getElementById('bannerImageUrl').value = d.imageUrl || '';
                document.getElementById('bannerDescription').value = d.description || '';
                document.getElementById('bannerLink').value = d.link || '';
                bannerFormTitle.textContent = 'Editing Banner';
                saveBannerBtn.textContent = 'Update Banner';
                cancelEditBannerBtn.style.display = 'inline-block';
                document.querySelector('.banner-tab-link[data-tab="addBannerTab"]').click(); 
                window.scrollTo(0, 0);
            } else {
                displayMessage(addBannerMessage, 'Banner not found.', 'error');
            }
        } catch(err) {
            console.error("Error loading banner for editing:", err);
            displayMessage(addBannerMessage, 'Could not load banner for editing.', 'error');
        }
    }


    // --- User Management Logic ---
    userSearchBtn.addEventListener('click', async () => {
        const emailToSearch = userSearchEmailInput.value.trim();
        if (!emailToSearch) {
            displayUserMessage('Please enter an email to search.', 'error');
            return;
        }
        
        hideUserMessage();
        userEditFormSection.classList.add('hidden');
        userSearchBtn.disabled = true;
        userSearchBtn.textContent = 'Searching...';

        try {
            const usersRef = db.collection("users");
            const q = usersRef.where("email", "==", emailToSearch);
            const querySnapshot = await q.get();

            if (querySnapshot.empty) {
                displayUserMessage(`No user found with email: ${emailToSearch}. You can create a new document.`, 'info'); 
                clearUserForm();
                userEditEmailInput.value = emailToSearch;
                userFormTitle.textContent = "Create New User Document";
                userDocIdInput.value = "Will be auto-generated upon creation";
                userUpdateBtn.classList.add('hidden');
                userCreateBtn.classList.remove('hidden');
            } else {
                const userDoc = querySnapshot.docs[0];
                const userData = userDoc.data();
                displayUserMessage('User found. You can now edit the details below.', 'success');
                userDocIdInput.value = userDoc.id;
                userEditNameInput.value = userData.name || '';
                userEditEmailInput.value = userData.email || '';
                userEditActivatedSelect.value = userData.activated ? 'true' : 'false';
                userEditExpiresAtInput.value = formatTimestampForInput(userData.expiresAt);
                userFormTitle.textContent = "Edit User Document";
                userCreateBtn.classList.add('hidden');
                userUpdateBtn.classList.remove('hidden');
            }
            userEditFormSection.classList.remove('hidden');
            userFormDivider.classList.remove('hidden');
        } catch (error) {
            console.error("Error searching user: ", error);
            displayUserMessage(`An error occurred while searching: ${error.message}`, 'error');
        } finally {
            userSearchBtn.disabled = false;
            userSearchBtn.textContent = 'Search User';
        }
    });

    userUpdateBtn.addEventListener('click', async () => {
        const userId = userDocIdInput.value;
        if (!userId || userId === "Will be auto-generated upon creation") {
            displayUserMessage('No user document ID found. Please search for a user or use "Create New Document".', 'error');
            return;
        }
        userUpdateBtn.disabled = true;
        userUpdateBtn.textContent = 'Updating...';
        try {
            const userDocRef = db.collection("users").doc(userId);
            const dateValue = userEditExpiresAtInput.value ? new Date(userEditExpiresAtInput.value) : null;

            await userDocRef.update({
                name: userEditNameInput.value,
                email: userEditEmailInput.value,
                activated: userEditActivatedSelect.value === 'true',
                expiresAt: dateValue ? firebase.firestore.Timestamp.fromDate(dateValue) : null 
            });
            displayUserMessage('User document updated successfully!', 'success');
        } catch (error) {
            console.error("Error updating user document: ", error);
            displayUserMessage(`Failed to update document: ${error.message}`, 'error');
        } finally {
            userUpdateBtn.disabled = false;
            userUpdateBtn.textContent = 'Update Document';
        }
    });

    userCreateBtn.addEventListener('click', async () => {
        const email = userEditEmailInput.value.trim();
        const name = userEditNameInput.value.trim();
        if (!email || !name) {
            displayUserMessage('Email and Name are required to create a new document.', 'error');
            return;
        }
        userCreateBtn.disabled = true;
        userCreateBtn.textContent = 'Creating...';
        try {
            const newDocRef = db.collection("users").doc(); 
            const dateValue = userEditExpiresAtInput.value ? new Date(userEditExpiresAtInput.value) : null;

            await newDocRef.set({
                name: name,
                email: email,
                phone: "", 
                profileImage: "",
                activated: userEditActivatedSelect.value === 'true',
                expiresAt: dateValue ? firebase.firestore.Timestamp.fromDate(dateValue) : null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                deleted: false
            });
            userDocIdInput.value = newDocRef.id;
            displayUserMessage(`New document created successfully with ID: ${newDocRef.id}`, 'success');
            userCreateBtn.classList.add('hidden');
            userUpdateBtn.classList.remove('hidden');
            userFormTitle.textContent = "Edit User Document"; 
        } catch (error) {
            console.error("Error creating user document: ", error);
            displayUserMessage(`Failed to create document: ${error.message}`, 'error');
        } finally {
            userCreateBtn.disabled = false;
            userCreateBtn.textContent = 'Create New Document';
        }
    });
    
    // --- Notification Panel Logic ---
    if (notifForm) {
        // Live Preview Logic
        notifTitleInput.addEventListener('input', () => {
            previewTitle.textContent = notifTitleInput.value || 'Notification Title';
        });

        notifBodyInput.addEventListener('input', () => {
            previewBody.textContent = notifBodyInput.value || 'Notification body will appear here...';
        });

        notifImageUrlInput.addEventListener('input', () => {
            const url = notifImageUrlInput.value;
            if (url) {
                previewImage.src = url;
                previewImage.style.display = 'block';
                previewImage.onerror = () => { // Handle broken image links
                    previewImage.style.display = 'none';
                };
            } else {
                previewImage.style.display = 'none';
            }
        });

        // Form Submission Logic for the Notification Tab itself
        notifForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const title = notifTitleInput.value;
            const body = notifBodyInput.value;
            const imageUrl = notifImageUrlInput.value;
            const url = notifUrlInput.value; // Get the URL from the new input

            if (!title && !body) { // Changed to check both title and body for notification form submission
                displayMessage(notificationMessage, 'Please fill in either the title or the body field for the notification.', 'error');
                return;
            }

            setLoading(sendNotificationBtn, true);
            // Use the updated sendNotification function
            const success = await sendNotification(title, body, imageUrl, url, notificationMessage);
            setLoading(sendNotificationBtn, false);

            if (success) {
                notifForm.reset();
                previewTitle.textContent = 'Notification Title';
                previewBody.textContent = 'Notification body will appear here...';
                previewImage.style.display = 'none';
            }
        });
    }

});

</script>

</body>
</html>
